<!DOCTYPE html>
<html class="h-full" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RealTime-Clipboard</title>
    <script src="/socket.io/socket.io.js"></script>
    <link href="tailwind.min.css" rel="stylesheet" />
    <style>
      body {
        font-family: "Inter", sans-serif;
      }

      #drop-zone {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: none;
        align-items: center;
        justify-content: center;
        color: #fff;
        font-size: 24px;
        z-index: 1000;
      }

      .sidebar {
        width: 23%;
        min-width: 250px;
        background-color: #061228;
        padding: 20px;
        display: flex;
        flex-direction: column;
        max-height: 100%;
        box-sizing: border-box;
        position: relative;
        overflow: auto;
      }

      .resizer {
        width: 5px;
        background-color: #4a5568;
        cursor: ew-resize;
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        z-index: 1;
      }

      .file-list {
        overflow-y: auto;
        flex-grow: 1;
        max-height: calc(100vh - 220px); /* Adjust based on the actual height of other elements */
      }

      .content {
        flex-grow: 1;
        padding: 20px;
      }

      #progress-container {
        display: none;
        backdrop-filter: blur(4px);
        border-top: 1px solid #4a5568;
      }

      .progress-bar-animation {
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0% {
          box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.5);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(59, 130, 246, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
        }
      }

      #chunk-progress-bar {
        background: linear-gradient(90deg, #60a5fa, #3b82f6, #2563eb);
        background-size: 200% 100%;
        animation: shimmer 2s linear infinite;
      }

      #overall-progress-bar {
        background: linear-gradient(90deg, #10b981, #059669, #047857);
      }

      @keyframes shimmer {
        0% {
          background-position: -200% 0;
        }
        100% {
          background-position: 200% 0;
        }
      }

      /* Media query for mobile devices */
      @media (max-width: 768px) {
        body {
          flex-direction: column-reverse;
        }

        textarea {
          resize: vertical;
          min-height: 300px;
        }

        .sidebar {
          width: 100%;
          min-width: 100%;
          padding: 10px;
        }

        .resizer {
          display: none;
        }

        .content {
          padding: 10px;
          width: 100%;
        }

        .file-list {
          max-height: 300px; /* Adjust based on the actual height of other elements */
        }
      }
    </style>
  </head>

  <body class="bg-black text-gray-100 flex min-h-full">
    <!-- Sidebar -->
    <div class="sidebar">
      <div>
        <div class="mb-6">
          <% if (typeof environmentName !== 'undefined' && environmentName !== 'default') { %>
          <div class="mb-4 p-3 bg-blue-900 rounded-lg border border-blue-500">
            <div class="flex items-center justify-between">
              <h2 class="text-sm font-medium text-blue-200">Environment</h2>
              <span class="text-blue-300 font-mono text-sm"><%= environmentName %></span>
            </div>
          </div>
          <% } %>
          <h3 class="text-xl font-semibold mb-2">Upload Files</h3>
          <form
            id="upload-form"
            class="space-y-4"
            action="<%= typeof environmentPath !== 'undefined' ? environmentPath : '' %>/upload"
            method="post"
            enctype="multipart/form-data"
          >
            <input
              id="file-input"
              type="file"
              name="files"
              multiple
              required
              class="block w-full text-sm text-gray-200 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-500 file:text-gray-100 hover:file:bg-blue-400"
            />
            <button
              type="submit"
              class="w-full py-2 bg-blue-500 text-gray-100 rounded-lg hover:bg-blue-400 transition duration-300"
            >
              Upload
            </button>
          </form>
        </div>
        <div>
          <h3 class="text-xl font-semibold mb-2">Files</h3>
          <ul class="file-list w-full space-y-2" id="file-list">
            <% files.forEach(file => { %>
            <li
              data-filename="<%= file %>"
              class="flex justify-between items-center bg-gray-700 p-4 rounded-lg"
            >
              <a
                href="<%= typeof environmentPath !== 'undefined' ? environmentPath : '' %>/files/<%= file %>"
                download
                class="text-gray-200 hover:text-blue-400 transition duration-300"
              >
                <%= file %>
              </a>
              <button
                type="button"
                class="delete-button bg-red-500 text-gray-100 px-3 py-1 rounded-lg hover:bg-red-400 transition duration-300"
              >
                Delete
              </button>
            </li>
            <% }) %>
          </ul>
        </div>
      </div>
      <div class="resizer"></div>
    </div>

    <!-- Main Content -->
    <div
      style="display: flex"
      class="content flex flex-col items-center justify-center"
    >
      <textarea
        id="textarea"
        style="flex-grow: 1; background-color: #121f33"
        class="w-full h-full h-64 p-4 mb-4 rounded-lg resize-none focus:outline-none focus:ring-2 focus:ring-blue-500"
        placeholder="Type something..."
      ></textarea>
    </div>

    <div
      id="progress-container"
      class="fixed bottom-0 left-0 w-full bg-gray-800 p-3 shadow-lg"
    >
      <div id="progress-text" class="text-white text-sm mb-2 font-medium"></div>
      
      <!-- Overall Progress -->
      <div class="mb-3">
        <div class="flex justify-between items-center mb-1">
          <span class="text-xs text-gray-300">Overall Progress</span>
          <span id="overall-percentage" class="text-xs text-gray-300">0%</span>
        </div>
        <div class="w-full bg-gray-600 rounded-full h-2">
          <div id="overall-progress-bar" class="h-2 bg-green-500 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
      </div>
      
      <!-- Current Chunk Progress -->
      <div id="chunk-progress-section" style="display: none;">
        <div class="flex justify-between items-center mb-1">
          <span class="text-xs text-gray-300" id="chunk-label">Current Chunk</span>
          <div class="flex items-center gap-2">
            <span id="chunk-percentage" class="text-xs text-gray-300">0%</span>
            <button 
              id="cancel-upload-btn" 
              class="text-xs bg-red-500 hover:bg-red-600 text-white px-2 py-0.5 rounded transition-colors duration-200"
              onclick="cancelAllUploads()"
              title="Cancel upload"
            >
              Cancel
            </button>
          </div>
        </div>
        <div class="w-full bg-gray-600 rounded-full h-1.5">
          <div id="chunk-progress-bar" class="h-1.5 bg-blue-400 rounded-full transition-all duration-150" style="width: 0%"></div>
        </div>
      </div>
    </div>

    <div id="drop-zone" class="flex items-center justify-center">
      Drop files here to upload
    </div>

    <script>
      const socket = io();
      const textarea = document.getElementById("textarea");
      const fileList = document.getElementById("file-list");
      const dropZone = document.getElementById("drop-zone");
      const fileInput = document.getElementById("file-input");
      const uploadForm = document.getElementById("upload-form");
      const resizer = document.querySelector(".resizer");
      const sidebar = document.querySelector(".sidebar");
      const progressContainer = document.getElementById("progress-container");
      const progressText = document.getElementById("progress-text");
      const overallProgressBar = document.getElementById("overall-progress-bar");
      const overallPercentage = document.getElementById("overall-percentage");
      const chunkProgressSection = document.getElementById("chunk-progress-section");
      const chunkProgressBar = document.getElementById("chunk-progress-bar");
      const chunkPercentage = document.getElementById("chunk-percentage");
      const chunkLabel = document.getElementById("chunk-label");

      // Get current environment from URL
      const currentPath = window.location.pathname;
      const environmentName = currentPath === '/' ? 'default' : currentPath.slice(1);
      const environmentPath = currentPath === '/' ? '' : currentPath;

      // Join the appropriate environment room
      socket.emit('joinEnvironment', environmentName);

      // Track active uploads for cleanup
      let activeUploads = new Set();
      
      // Handle page unload/close - cancel active uploads
      window.addEventListener('beforeunload', function(event) {
        if (activeUploads.size > 0) {
          // Cancel all active uploads
          activeUploads.forEach(uploadId => {
            // Use sendBeacon for reliable delivery during page unload
            navigator.sendBeacon(`/upload/cancel/${uploadId}`);
          });
          
          // Optional: Show a warning if user tries to leave during upload
          event.preventDefault();
          event.returnValue = 'Upload in progress. Are you sure you want to leave?';
          return event.returnValue;
        }
      });
      
      // Handle visibility change (tab switch, minimize)
      document.addEventListener('visibilitychange', function() {
        if (document.hidden && activeUploads.size > 0) {
          console.log('Page hidden with active uploads, monitoring for cleanup...');
          
          // Start a timer to cancel uploads if page stays hidden too long
          setTimeout(() => {
            if (document.hidden && activeUploads.size > 0) {
              console.log('Page still hidden after 5 minutes, canceling uploads...');
              activeUploads.forEach(uploadId => {
                fetch(`/upload/cancel/${uploadId}`, { method: 'DELETE' })
                  .catch(err => console.log('Failed to cancel upload:', err));
              });
            }
          }, 5 * 60 * 1000); // 5 minutes
        }
      });

      socket.on("textUpdate", (text) => {
        textarea.value = text;
      });

      textarea.addEventListener("input", () => {
        socket.emit("textChange", textarea.value);
      });

      socket.on("fileUpdate", () => {
        fetch(window.location.pathname)
          .then((response) => response.text())
          .then((html) => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, "text/html");
            const newFileList = doc.getElementById("file-list");
            if (newFileList) {
              fileList.innerHTML = newFileList.innerHTML;
              attachDeleteEventListeners(); // Re-attach event listeners after updating the file list
            }
          })
          .catch((error) => {
            console.error('Error updating file list:', error);
          });
      });

      uploadForm.addEventListener("submit", (event) => {
        event.preventDefault();
        const files = fileInput.files;
        if (files.length > 0) {
          uploadFiles(files);
        }
      });

      let dragCounter = 0;

      document.addEventListener("dragenter", (event) => {
        event.preventDefault();
        if (
          event.dataTransfer.items &&
          event.dataTransfer.items[0].kind === "file"
        ) {
          dragCounter++;
          dropZone.style.display = "flex";
        }
      });

      document.addEventListener("dragleave", (event) => {
        event.preventDefault();
        if (
          event.dataTransfer.items &&
          event.dataTransfer.items[0].kind === "file"
        ) {
          dragCounter--;
          if (dragCounter === 0) {
            dropZone.style.display = "none";
          }
        }
      });

      document.addEventListener("drop", (event) => {
        event.preventDefault();
        dropZone.style.display = "none";
        dragCounter = 0;
        const files = event.dataTransfer.files;
        if (files.length > 0) {
          uploadFiles(files);
        }
      });

      window.addEventListener("dragleave", (event) => {
        if (event.clientX === 0 && event.clientY === 0) {
          dropZone.style.display = "none";
          dragCounter = 0;
        }
      });

      document.addEventListener("dragover", (event) => {
        event.preventDefault();
      });

      textarea.addEventListener("dragover", (event) => {
        event.stopPropagation();
      });

      textarea.addEventListener("drop", (event) => {
        event.stopPropagation();
      });

      function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
      }

      // Function to cancel all active uploads
      function cancelAllUploads() {
        if (activeUploads.size === 0) {
          alert('No active uploads to cancel.');
          return;
        }
        
        const uploadCount = activeUploads.size;
        if (confirm(`Are you sure you want to cancel ${uploadCount} active upload(s)?`)) {
          console.log(`Canceling ${uploadCount} active uploads...`);
          
          activeUploads.forEach(async (uploadId) => {
            try {
              await fetch(`${environmentPath}/upload/cancel/${uploadId}`, { method: 'DELETE' });
              console.log(`Canceled upload: ${uploadId}`);
            } catch (error) {
              console.error(`Failed to cancel upload ${uploadId}:`, error);
            }
          });
          
          activeUploads.clear();
          
          // Hide progress bars and show cancellation message
          progressContainer.style.display = "none";
          overallProgressBar.style.width = "0%";
          overallPercentage.textContent = "0%";
          chunkProgressBar.style.width = "0%";
          chunkPercentage.textContent = "0%";
          chunkProgressSection.style.display = "none";
          
          alert('Upload(s) canceled successfully. Files will be cleaned up shortly.');
        }
      }

      function uploadFiles(files) {
        // Check if any files are larger than 45MB (leaving buffer for Cloudflare's 50MB limit)
        const CHUNK_SIZE = 45 * 1024 * 1024; // 45MB chunks
        let hasLargeFiles = false;
        
        for (let file of files) {
          if (file.size > CHUNK_SIZE) {
            hasLargeFiles = true;
            break;
          }
        }
        
        if (hasLargeFiles) {
          uploadLargeFiles(files);
        } else {
          uploadSmallFiles(files);
        }
      }

      function uploadSmallFiles(files) {
        const formData = new FormData();
        for (let i = 0; i < files.length; i++) {
          formData.append('files', files[i]);
        }

        const xhr = new XMLHttpRequest();
        xhr.open("POST", "/upload", true);

        xhr.upload.onprogress = function (event) {
          if (event.lengthComputable) {
            const percentComplete = (event.loaded / event.total) * 100;
            overallProgressBar.style.width = percentComplete + "%";
            overallPercentage.textContent = Math.round(percentComplete) + "%";
          }
        };

        xhr.onloadstart = function () {
          progressContainer.style.display = "block";
          progressText.textContent = "Uploading files...";
          chunkProgressSection.style.display = "none";
        };

        xhr.onloadend = function () {
          progressContainer.style.display = "none";
          overallProgressBar.style.width = "0%";
          overallPercentage.textContent = "0%";
          progressText.textContent = "";
          socket.emit("fileUpdate");
        };

        xhr.send(formData);
      }

      async function uploadLargeFiles(files) {
        const CHUNK_SIZE = 45 * 1024 * 1024; // 45MB chunks
        progressContainer.style.display = "block";
        chunkProgressSection.style.display = "block";
        
        try {
          let totalProgress = 0;
          const totalFiles = files.length;
          
          for (let i = 0; i < files.length; i++) {
            const file = files[i];
            const fileProgress = `File ${i + 1}/${totalFiles}: `;
            
            if (file.size > CHUNK_SIZE) {
              progressText.textContent = `${fileProgress}Uploading "${file.name}" (${formatFileSize(file.size)})`;
              await uploadFileInChunks(file, CHUNK_SIZE, i, totalFiles);
            } else {
              progressText.textContent = `${fileProgress}Uploading "${file.name}" (${formatFileSize(file.size)})`;
              chunkProgressSection.style.display = "none";
              await uploadSingleFile(file);
              
              // Update overall progress for small files
              totalProgress = ((i + 1) / totalFiles) * 100;
              overallProgressBar.style.width = totalProgress + "%";
              overallPercentage.textContent = Math.round(totalProgress) + "%";
            }
          }
          
          progressText.textContent = "✅ All uploads completed successfully!";
          overallProgressBar.style.width = "100%";
          overallPercentage.textContent = "100%";
          chunkProgressSection.style.display = "none";
          
          setTimeout(() => {
            progressText.textContent = "";
          }, 2000);
        } catch (error) {
          console.error('Upload failed:', error);
          progressText.textContent = "❌ Upload failed!";
          chunkProgressSection.style.display = "none";
          
          // Cancel any active uploads on error
          activeUploads.forEach(uploadId => {
            fetch(`/upload/cancel/${uploadId}`, { method: 'DELETE' })
              .catch(err => console.log('Failed to cancel upload after error:', err));
          });
          activeUploads.clear();
          
          alert('Upload failed: ' + error.message);
          setTimeout(() => {
            progressText.textContent = "";
          }, 3000);
        } finally {
          setTimeout(() => {
            progressContainer.style.display = "none";
            overallProgressBar.style.width = "0%";
            overallPercentage.textContent = "0%";
            chunkProgressBar.style.width = "0%";
            chunkPercentage.textContent = "0%";
          }, 2000);
          socket.emit("fileUpdate");
        }
      }

      async function uploadSingleFile(file) {
        const formData = new FormData();
        formData.append('files', file);

        return new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          xhr.open("POST", "/upload", true);

          xhr.onload = function () {
            if (xhr.status === 200) {
              resolve();
            } else {
              reject(new Error(`Failed to upload ${file.name}`));
            }
          };

          xhr.onerror = function () {
            reject(new Error(`Network error uploading ${file.name}`));
          };

          xhr.send(formData);
        });
      }

      async function uploadFileInChunks(file, chunkSize, fileIndex, totalFiles) {
        const totalChunks = Math.ceil(file.size / chunkSize);
        
        // Initiate upload session
        const initResponse = await fetch(`${environmentPath}/upload/initiate`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            fileName: file.name,
            fileSize: file.size,
            totalChunks: totalChunks
          })
        });

        if (!initResponse.ok) {
          const errorText = await initResponse.text();
          console.error('Initiate upload error:', errorText);
          throw new Error(`Failed to initiate upload for ${file.name}: ${errorText}`);
        }

        const { uploadId } = await initResponse.json();
        
        // Track this upload for cleanup
        activeUploads.add(uploadId);
        
        // Upload chunks sequentially with progress tracking
        for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
          const start = chunkIndex * chunkSize;
          const end = Math.min(start + chunkSize, file.size);
          const chunk = file.slice(start, end);
          
          // Update chunk progress info
          chunkLabel.textContent = `Chunk ${chunkIndex + 1} of ${totalChunks} (${formatFileSize(chunk.size)})`;
          chunkProgressBar.style.width = "0%";
          chunkPercentage.textContent = "0%";
          
          const formData = new FormData();
          formData.append('uploadId', uploadId);
          formData.append('chunkIndex', chunkIndex);
          formData.append('chunk', chunk);

          // Create XMLHttpRequest for progress tracking
          await new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            
            xhr.upload.onprogress = function(event) {
              if (event.lengthComputable) {
                const chunkProgress = (event.loaded / event.total) * 100;
                chunkProgressBar.style.width = chunkProgress + "%";
                chunkPercentage.textContent = Math.round(chunkProgress) + "%";
                
                // Calculate overall progress
                const completedChunks = chunkIndex;
                const currentChunkProgress = chunkProgress / 100;
                const fileProgress = (completedChunks + currentChunkProgress) / totalChunks;
                const totalProgress = ((fileIndex + fileProgress) / totalFiles) * 100;
                
                overallProgressBar.style.width = totalProgress + "%";
                overallPercentage.textContent = Math.round(totalProgress) + "%";
              }
            };
            
            xhr.onload = function() {
              if (xhr.status === 200) {
                // Chunk upload completed
                chunkProgressBar.style.width = "100%";
                chunkPercentage.textContent = "100%";
                resolve();
              } else {
                reject(new Error(`Failed to upload chunk ${chunkIndex + 1}/${totalChunks} for ${file.name}`));
              }
            };
            
            xhr.onerror = function() {
              reject(new Error(`Network error uploading chunk ${chunkIndex + 1}/${totalChunks} for ${file.name}`));
            };
            
            xhr.open('POST', `${environmentPath}/upload/chunk`);
            xhr.send(formData);
          });
          
          // Brief pause between chunks for better visual feedback
          await new Promise(resolve => setTimeout(resolve, 100));
        }

        // Complete upload
        progressText.textContent = progressText.textContent.replace(/Uploading/, 'Finalizing');
        chunkLabel.textContent = "Combining chunks...";
        chunkProgressBar.style.width = "100%";
        chunkPercentage.textContent = "100%";
        
        const completeResponse = await fetch(`${environmentPath}/upload/complete`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ uploadId })
        });

        if (!completeResponse.ok) {
          const errorText = await completeResponse.text();
          console.error('Complete upload error:', errorText);
          throw new Error(`Failed to complete upload for ${file.name}: ${errorText}`);
        }
        
        // Remove from active uploads when completed successfully
        activeUploads.delete(uploadId);
        
        // Force a file update to refresh the list
        socket.emit("fileUpdate");
      }

      function attachDeleteEventListeners() {
        const deleteButtons = document.querySelectorAll(".delete-button");
        deleteButtons.forEach((button) => {
          button.addEventListener("click", () => {
            const li = button.closest("li");
            const filename = li.getAttribute("data-filename");

            fetch(`${environmentPath}/files/${filename}`, {
              method: "DELETE",
            }).then((response) => {
              if (response.ok) {
                li.remove();
                socket.emit("fileUpdate");
              } else {
                console.error("Failed to delete file");
              }
            });
          });
        });
      }

      attachDeleteEventListeners(); // Attach event listeners initially

      // Resizer logic
      resizer.addEventListener("mousedown", function (e) {
        document.addEventListener("mousemove", resize);
        document.addEventListener("mouseup", stopResize);
      });

      function resize(e) {
        const newWidth = e.clientX - sidebar.offsetLeft;
        sidebar.style.width = newWidth + "px";
      }

      function stopResize() {
        document.removeEventListener("mousemove", resize);
        document.removeEventListener("mouseup", stopResize);
      }
    </script>
  </body>
</html>
