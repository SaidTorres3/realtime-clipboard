<!DOCTYPE html>
<html class="h-full" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RealTime Clipboard 2.0 - Data Sharing</title>
    <script src="/socket.io/socket.io.js"></script>
    <link href="tailwind.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500;600&display=swap" rel="stylesheet" />
    <link href="/styles.css" rel="stylesheet" />
    <!-- inline styles moved to views/styles.css -->
  </head>

  <body>
    <!-- Main Container -->
    <div class="flex main-container" style="min-height: 100vh;">
      <!-- Sidebar -->
      <div class="sidebar">
        <div class="sidebar-content">
          <!-- Environment Badge -->
          <% if (typeof environmentName !== 'undefined' && environmentName !== 'default') { %>
          <div class="environment-badge">
            <div class="environment-label">Environment</div>
            <div class="environment-name"><%= environmentName %></div>
          </div>
          <% } %>

          <!-- Upload Section -->
          <div class="sidebar-section">
            <h3 class="section-title">
              <i class="fas fa-cloud-upload-alt"></i>
              File Upload
            </h3>
            
            <form id="upload-form" action="<%= typeof environmentPath !== 'undefined' ? environmentPath : '' %>/upload" method="post" enctype="multipart/form-data">
              <div class="upload-area" onclick="document.getElementById('file-input').click()">
                <div class="upload-icon">
                  <i class="fas fa-plus-circle"></i>
                </div>
                <div class="upload-text">Drop files here or click to browse</div>
                <div class="upload-subtext">Files upload automatically ‚Ä¢ Supports multiple files and large uploads</div>
                <input
                  id="file-input"
                  type="file"
                  name="files"
                  multiple
                  style="display: none;"
                />
              </div>
            </form>

            <!-- Inline Progress Section -->
            <div id="inline-progress-container" style="display: none; margin-top: 20px;">
              <div class="progress-card">
                <div id="progress-text" class="progress-label mb-2">
                  <i class="fas fa-spinner fa-spin" style="margin-right: 8px;"></i>
                  Processing...
                </div>
                
                <!-- Overall Progress -->
                <div class="progress-section">
                  <div class="progress-header">
                    <span class="progress-label">Overall Progress</span>
                    <span id="overall-percentage" class="progress-percentage">0%</span>
                  </div>
                  <div class="progress-track">
                    <div id="overall-progress-bar" class="progress-bar" style="width: 0%"></div>
                  </div>
                </div>
                
                <!-- Current Chunk Progress -->
                <div id="chunk-progress-section" style="display: none;" class="progress-section">
                  <div class="progress-header">
                    <span class="progress-label" id="chunk-label">Current Chunk</span>
                    <div class="flex items-center gap-2">
                      <span id="chunk-percentage" class="progress-percentage">0%</span>
                      <button 
                        id="cancel-upload-btn" 
                        class="btn btn-danger"
                        style="padding: 4px 8px; font-size: 11px;"
                        onclick="cancelAllUploads()"
                        title="Cancel upload"
                      >
                        <i class="fas fa-times"></i>
                      </button>
                    </div>
                  </div>
                  <div class="progress-track">
                    <div id="chunk-progress-bar" class="progress-bar" style="width: 0%"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Files Section -->
          <div class="sidebar-section flex-1">
            <div class="flex items-center justify-between mb-4">
              <h3 class="section-title">
                <i class="fas fa-folder-open"></i>
                Shared Files
              </h3>
              <span id="file-count" class="stat-value"><%= files.length %></span>
            </div>
            
            <div class="file-list" id="file-list">
              <% if (files.length === 0) { %>
              <div style="text-align: center; padding: 40px 20px; color: var(--text-muted);">
                <i class="fas fa-folder-open" style="font-size: 48px; margin-bottom: 15px; display: block; opacity: 0.5;"></i>
                <p>No files uploaded yet</p>
                <p style="font-size: 12px; margin-top: 8px;">üí° Paste images directly with Ctrl+V</p>
              </div>
              <% } else { %>
                <% files.forEach(file => { 
                  const fileName = typeof file === 'string' ? file : file.name;
                  const isImage = typeof file === 'object' ? file.isImage : false;
                %>
                <div class="file-item <%= isImage ? 'has-image' : '' %>" data-filename="<%= fileName %>">
                  <div class="file-info">
                    <% if (isImage) { %>
                      <div class="image-thumbnail" 
                           data-image-url="<%= typeof environmentPath !== 'undefined' ? environmentPath : '' %>/files/<%= fileName %>"
                           data-filename="<%= fileName %>">
                        <img src="<%= typeof environmentPath !== 'undefined' ? environmentPath : '' %>/files/<%= fileName %>" 
                             alt="<%= fileName %>" 
                             class="thumbnail-img"
                             loading="lazy" />
                        <div class="image-overlay">
                          <i class="fas fa-search-plus"></i>
                        </div>
                      </div>
                    <% } else { %>
                      <div class="file-icon">
                        <i class="fas fa-file" id="file-icon-<%= fileName.replace(/[^a-zA-Z0-9]/g, '') %>"></i>
                      </div>
                    <% } %>
                    <a
                      href="<%= typeof environmentPath !== 'undefined' ? environmentPath : '' %>/files/<%= fileName %>"
                      download
                      class="file-name"
                      title="<%= fileName %>"
                    >
                      <%= fileName %>
                    </a>
                  </div>
                  <button
                    type="button"
                    class="delete-button btn btn-danger"
                    style="padding: 8px 12px; font-size: 12px;"
                    title="Delete file"
                  >
                    <i class="fas fa-trash"></i>
                  </button>
                </div>
                <% }) %>
              <% } %>
            </div>
          </div>
        </div>
        <div class="resizer"></div>
      </div>

      <!-- Main Content Area -->
      <div class="content-area">
        <!-- Main Editor -->
        <div class="main-editor">
          <div class="editor-wrapper">
            <div class="editor-header">
              <div class="editor-title">
                <i class="fas fa-keyboard"></i>
                Live Editor
              </div>
              <div class="flex items-center gap-2">
                <div class="connection-status">
                  <div class="status-dot"></div>
                  <span>Connected</span>
                </div>
                <button class="clear-btn" onclick="clearClipboard()" title="Clear all content">
                  <i class="fas fa-eraser"></i>
                  Clear
                </button>
              </div>
            </div>
            <textarea
              id="textarea"
              placeholder="üöÄ Welcome to RealTime Clipboard 2.0!

Start typing your shared content here...

‚ú® Features:
‚Ä¢ Real-time synchronization across all connected devices
‚Ä¢ File sharing with drag & drop support
‚Ä¢ Large file upload with chunked processing
‚Ä¢ Clean, performance-optimized design

üí° Tips:
‚Ä¢ Use Ctrl/Cmd + A to select all text
‚Ä¢ Drag files directly into the sidebar to upload
‚Ä¢ Content is automatically saved and synced"
            ></textarea>
          </div>
        </div>
      </div>
    </div>



    <!-- Drop Zone -->
    <div id="drop-zone">
      <div class="drop-zone-content">
        <div class="drop-zone-icon">
          <i class="fas fa-cloud-upload-alt"></i>
        </div>
        <div class="drop-zone-title">Drop Files Here</div>
        <div class="drop-zone-text">Release to upload your files instantly</div>
      </div>
    </div>

    <!-- Custom Confirmation Dialog -->
    <div id="confirm-overlay" class="confirm-overlay">
      <div class="confirm-dialog">
        <div class="confirm-header">
          <div id="confirm-icon" class="confirm-icon">
            <i class="fas fa-question-circle"></i>
          </div>
          <h3 id="confirm-title" class="confirm-title">Confirm Action</h3>
        </div>
        <div id="confirm-message" class="confirm-message">
          Are you sure you want to proceed?
        </div>
        <div class="confirm-buttons">
          <button id="confirm-cancel" class="confirm-btn secondary">Cancel</button>
          <button id="confirm-ok" class="confirm-btn primary">Confirm</button>
        </div>
      </div>
    </div>

    <!-- Image Preview Modal -->
    <div id="image-modal" class="image-modal">
      <div class="modal-content">
        <button class="modal-close" onclick="closeImageModal()">√ó</button>
        <img id="modal-image" class="modal-image" src="" alt="">
        <div id="modal-filename" class="modal-filename"></div>
      </div>
    </div>

    <script>
      const socket = io();
      const textarea = document.getElementById("textarea");
      const fileList = document.getElementById("file-list");
      const dropZone = document.getElementById("drop-zone");
      const fileInput = document.getElementById("file-input");
      const uploadForm = document.getElementById("upload-form");
      const resizer = document.querySelector(".resizer");
      const sidebar = document.querySelector(".sidebar");
      const progressContainer = document.getElementById("inline-progress-container");
      const progressText = document.getElementById("progress-text");
      const overallProgressBar = document.getElementById("overall-progress-bar");
      const overallPercentage = document.getElementById("overall-percentage");
      const chunkProgressSection = document.getElementById("chunk-progress-section");
      const chunkProgressBar = document.getElementById("chunk-progress-bar");
      const chunkPercentage = document.getElementById("chunk-percentage");
      const chunkLabel = document.getElementById("chunk-label");
      const fileCount = document.getElementById("file-count");
      const filesCount = document.getElementById("files-count");
      const usersCount = document.getElementById("users-count");

      // Get current environment from URL
      const currentPath = window.location.pathname;
      const environmentName = currentPath === '/' ? 'default' : currentPath.slice(1);
      const environmentPath = currentPath === '/' ? '' : currentPath;
      
      // Application state
      let connectedUsers = 1;
      let activeUploads = new Set();
      
      // Custom Confirmation Dialog System
      function showConfirm(message, title = 'Confirm Action', type = 'warning') {
        return new Promise((resolve) => {
          const overlay = document.getElementById('confirm-overlay');
          const dialog = document.querySelector('.confirm-dialog');
          const titleEl = document.getElementById('confirm-title');
          const messageEl = document.getElementById('confirm-message');
          const iconEl = document.getElementById('confirm-icon');
          const okBtn = document.getElementById('confirm-ok');
          const cancelBtn = document.getElementById('confirm-cancel');
          
          // Set content
          titleEl.textContent = title;
          messageEl.textContent = message;
          
          // Set icon and styling based on type
          iconEl.className = `confirm-icon ${type}`;
          switch(type) {
            case 'danger':
              iconEl.innerHTML = '<i class="fas fa-exclamation-triangle"></i>';
              okBtn.className = 'confirm-btn danger';
              okBtn.textContent = 'Delete';
              break;
            case 'warning':
              iconEl.innerHTML = '<i class="fas fa-exclamation-triangle"></i>';
              okBtn.className = 'confirm-btn primary';
              okBtn.textContent = 'Confirm';
              break;
            case 'info':
              iconEl.innerHTML = '<i class="fas fa-info-circle"></i>';
              okBtn.className = 'confirm-btn primary';
              okBtn.textContent = 'OK';
              break;
            default:
              iconEl.innerHTML = '<i class="fas fa-question-circle"></i>';
              okBtn.className = 'confirm-btn primary';
              okBtn.textContent = 'Confirm';
          }
          
          // Show dialog with animation
          overlay.style.display = 'flex';
          requestAnimationFrame(() => {
            overlay.classList.add('show');
          });
          
          // Handle responses
          const handleResponse = (result) => {
            overlay.classList.remove('show');
            setTimeout(() => {
              overlay.style.display = 'none';
            }, 300);
            resolve(result);
          };
          
          // Event listeners
          okBtn.onclick = () => handleResponse(true);
          cancelBtn.onclick = () => handleResponse(false);
          
          // Close on overlay click
          overlay.onclick = (e) => {
            if (e.target === overlay) {
              handleResponse(false);
            }
          };
          
          // Keyboard support
          const handleKeydown = (e) => {
            if (e.key === 'Escape') {
              handleResponse(false);
              document.removeEventListener('keydown', handleKeydown);
            } else if (e.key === 'Enter') {
              handleResponse(true);
              document.removeEventListener('keydown', handleKeydown);
            }
          };
          
          document.addEventListener('keydown', handleKeydown);
          
          // Focus the OK button
          setTimeout(() => okBtn.focus(), 100);
        });
      }
      
      // Initialize application
      function initializeApp() {
        // Join the appropriate environment room
        socket.emit('joinEnvironment', environmentName);
        
        // Setup file icons
        updateFileIcons();
        
        // VNC performance check
        if (isVNCConnection()) {
          document.body.classList.add('no-animate');
          console.log('VNC connection detected - animations disabled for better performance');
        }
        
        // Add global click handler to close modal when clicking outside
        document.addEventListener('click', function(e) {
          const modal = document.getElementById('image-modal');
          if (e.target === modal) {
            closeImageModal();
          }
        });
        
        // Add escape key to close modal
        document.addEventListener('keydown', function(e) {
          if (e.key === 'Escape') {
            closeImageModal();
          }
        });
        
        console.log('%cüöÄ RealTime Clipboard 2.0!', 
          'color: #2563eb; font-size: 16px; font-weight: bold;');
      }

      // Detect VNC connection (heuristic)
      function isVNCConnection() {
        // Check for common VNC indicators
        const userAgent = navigator.userAgent.toLowerCase();
        const isLowBandwidth = navigator.connection && navigator.connection.downlink < 1;
        const isRemoteDesktop = userAgent.includes('rdp') || userAgent.includes('vnc') || 
                               userAgent.includes('remote') || window.screen.colorDepth < 24;
        
        return isLowBandwidth || isRemoteDesktop;
      }

      // Enhanced file icon detection
      function getFileIcon(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        const iconMap = {
          // Documents
          'pdf': 'fas fa-file-pdf',
          'doc': 'fas fa-file-word', 'docx': 'fas fa-file-word',
          'xls': 'fas fa-file-excel', 'xlsx': 'fas fa-file-excel',
          'ppt': 'fas fa-file-powerpoint', 'pptx': 'fas fa-file-powerpoint',
          'txt': 'fas fa-file-alt', 'md': 'fas fa-file-alt',
          
          // Images
          'jpg': 'fas fa-file-image', 'jpeg': 'fas fa-file-image',
          'png': 'fas fa-file-image', 'gif': 'fas fa-file-image',
          'svg': 'fas fa-file-image', 'webp': 'fas fa-file-image',
          
          // Code
          'js': 'fas fa-file-code', 'ts': 'fas fa-file-code',
          'html': 'fas fa-file-code', 'css': 'fas fa-file-code',
          'json': 'fas fa-file-code', 'xml': 'fas fa-file-code',
          'py': 'fas fa-file-code', 'java': 'fas fa-file-code',
          'cpp': 'fas fa-file-code', 'c': 'fas fa-file-code',
          
          // Archives
          'zip': 'fas fa-file-archive', 'rar': 'fas fa-file-archive',
          '7z': 'fas fa-file-archive', 'tar': 'fas fa-file-archive',
          'gz': 'fas fa-file-archive',
          
          // Media
          'mp3': 'fas fa-file-audio', 'wav': 'fas fa-file-audio',
          'mp4': 'fas fa-file-video', 'avi': 'fas fa-file-video',
          'mov': 'fas fa-file-video', 'wmv': 'fas fa-file-video'
        };
        
        return iconMap[ext] || 'fas fa-file';
      }

      // Update file icons and setup image thumbnails
      function updateFileIcons() {
        document.querySelectorAll('[data-filename]').forEach(item => {
          const filename = item.getAttribute('data-filename');
          const icon = item.querySelector('.file-icon i');
          
          // Check if this is an image file
          const isImage = isImageFile(filename);
          
          if (icon) {
            icon.className = getFileIcon(filename, isImage);
            if (isImage) {
              icon.parentElement.classList.add('image-icon');
            }
          }
        });
        
        // Setup hover functionality for image thumbnails
        setupImageThumbnails();
      }
      
      // Helper function to check if a file is an image
      function isImageFile(filename) {
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg', '.bmp', '.ico', '.tiff', '.tif'];
        const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
        return imageExtensions.includes(ext);
      }
      
      // Simple modal functions for image preview
      function showImageModal(imageUrl, filename) {
        console.log('Opening modal for:', imageUrl, filename);
        const modal = document.getElementById('image-modal');
        const modalImage = document.getElementById('modal-image');
        const modalFilename = document.getElementById('modal-filename');
        
        modalImage.src = imageUrl;
        modalImage.alt = filename;
        modalFilename.textContent = filename;
        
        modal.classList.add('show');
        document.body.style.overflow = 'hidden'; // Prevent background scrolling
      }
      
      function closeImageModal() {
        const modal = document.getElementById('image-modal');
        modal.classList.remove('show');
        document.body.style.overflow = ''; // Restore scrolling
      }
      
      // Setup click functionality for image thumbnails
      function setupImageThumbnails() {
        document.querySelectorAll('.image-thumbnail').forEach(thumbnail => {
          // Remove existing event listeners to prevent duplicates
          const newThumbnail = thumbnail.cloneNode(true);
          thumbnail.parentNode.replaceChild(newThumbnail, thumbnail);
          
          console.log('Setting up thumbnail click for:', newThumbnail);
          
          // Add click functionality
          newThumbnail.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const imageUrl = this.getAttribute('data-image-url');
            const filename = this.getAttribute('data-filename');
            
            console.log('Thumbnail clicked:', imageUrl, filename);
            
            if (imageUrl && filename) {
              showImageModal(imageUrl, filename);
            }
          });
        });
      }

      // Clear clipboard function
      async function clearClipboard() {
        if (textarea.value.trim()) {
          const confirmed = await showConfirm(
            'This will permanently clear all clipboard content.\n\nThis action cannot be undone.',
            'Clear Clipboard',
            'warning'
          );
          
          if (confirmed) {
            textarea.value = '';
            socket.emit("textChange", '');
            showNotification('Clipboard cleared successfully', 'success');
          }
        }
      }

      // Simple notification system (VNC friendly - no complex animations)
      function showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 80px;
          right: 20px;
          z-index: 1001;
          background: var(--card-bg);
          border: 2px solid var(--primary-blue);
          color: var(--text-primary);
          padding: 12px 16px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 500;
          max-width: 300px;
          box-shadow: var(--shadow-medium);
        `;
        
        const colors = {
          success: 'var(--success-green)',
          error: 'var(--danger-blue)',
          warning: 'var(--warning-yellow)',
          info: 'var(--primary-blue)'
        };
        
        notification.style.borderColor = colors[type] || colors.info;
        notification.textContent = message;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 3000);
      }

      // Update file counts
      function updateFileCounts() {
        const count = document.querySelectorAll('[data-filename]').length;
        if (fileCount) fileCount.textContent = count;
        if (filesCount) filesCount.textContent = count;
      }
      
      // Handle page unload/close - cancel active uploads
      window.addEventListener('beforeunload', function(event) {
        if (activeUploads.size > 0) {
          // Cancel all active uploads
          activeUploads.forEach(uploadId => {
            // Use sendBeacon for reliable delivery during page unload
            navigator.sendBeacon(`/upload/cancel/${uploadId}`);
          });
          
          // Optional: Show a warning if user tries to leave during upload
          event.preventDefault();
          event.returnValue = 'Upload in progress. Are you sure you want to leave?';
          return event.returnValue;
        }
      });
      
      // Handle visibility change (tab switch, minimize)
      document.addEventListener('visibilitychange', function() {
        if (document.hidden && activeUploads.size > 0) {
          console.log('Page hidden with active uploads, monitoring for cleanup...');
          
          // Start a timer to cancel uploads if page stays hidden too long
          setTimeout(() => {
            if (document.hidden && activeUploads.size > 0) {
              console.log('Page still hidden after 5 minutes, canceling uploads...');
              activeUploads.forEach(uploadId => {
                fetch(`/upload/cancel/${uploadId}`, { method: 'DELETE' })
                  .catch(err => console.log('Failed to cancel upload:', err));
              });
            }
          }, 5 * 60 * 1000); // 5 minutes
        }
      });

      // Socket event handlers
      socket.on("textUpdate", (text) => {
        if (textarea.value !== text) {
          textarea.value = text;
          // Subtle visual feedback without complex animations
          textarea.style.borderLeft = '3px solid var(--primary-blue)';
          setTimeout(() => {
            textarea.style.borderLeft = '';
          }, 1000);
        }
      });

      socket.on("userConnected", (data) => {
        connectedUsers = data.userCount || connectedUsers + 1;
        if (usersCount) usersCount.textContent = connectedUsers;
        showNotification(`üëã User joined (${connectedUsers} total)`, 'info');
      });

      socket.on("userDisconnected", (data) => {
        connectedUsers = data.userCount || Math.max(1, connectedUsers - 1);
        if (usersCount) usersCount.textContent = connectedUsers;
        showNotification(`üëã User left (${connectedUsers} total)`, 'info');
      });

      // Debounced input handling for better performance
      let inputTimeout;
      textarea.addEventListener("input", () => {
        clearTimeout(inputTimeout);
        inputTimeout = setTimeout(() => {
          socket.emit("textChange", textarea.value);
        }, 300);
      });

      socket.on("fileUpdate", () => {
        updateFileList();
      });

      function updateFileList() {
        fetch(window.location.pathname)
          .then((response) => response.text())
          .then((html) => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, "text/html");
            const newFileList = doc.getElementById("file-list");
            if (newFileList) {
              fileList.innerHTML = newFileList.innerHTML;
              attachDeleteEventListeners();
              updateFileIcons();
              setupImageThumbnails(); // Add this to setup hover functionality
              updateFileCounts();
            }
          })
          .catch((error) => {
            console.error('Error updating file list:', error);
            showNotification('Failed to update file list', 'error');
          });
      }

      // Prevent accidental form submission (no submit button now)
      uploadForm.addEventListener("submit", (event) => {
        event.preventDefault();
      });

      // Auto-upload on file selection
      fileInput.addEventListener('change', function(e) {
        const files = e.target.files;
        if (files.length > 0) {
          const fileNames = Array.from(files).map(f => f.name);
          const displayNames = fileNames.length > 3 
            ? fileNames.slice(0, 3).join(', ') + ` and ${fileNames.length - 3} more`
            : fileNames.join(', ');
          showNotification(`üìÅ Uploading: ${displayNames}`, 'info');
          
          // Automatically upload selected files
          uploadFiles(files);
          fileInput.value = ''; // Clear input after upload
        }
      });

      // Enhanced drag and drop with better visual feedback
      let dragCounter = 0;

      document.addEventListener("dragenter", (event) => {
        event.preventDefault();
        if (event.dataTransfer.items && event.dataTransfer.items[0].kind === "file") {
          dragCounter++;
          dropZone.style.display = "flex";
          
          // Add visual feedback to upload area
          const uploadArea = document.querySelector('.upload-area');
          if (uploadArea) {
            uploadArea.classList.add('dragover');
          }
        }
      });

      document.addEventListener("dragleave", (event) => {
        event.preventDefault();
        if (event.dataTransfer.items && event.dataTransfer.items[0].kind === "file") {
          dragCounter--;
          if (dragCounter === 0) {
            dropZone.style.display = "none";
            
            // Remove visual feedback
            const uploadArea = document.querySelector('.upload-area');
            if (uploadArea) {
              uploadArea.classList.remove('dragover');
            }
          }
        }
      });

      document.addEventListener("drop", (event) => {
        event.preventDefault();
        dropZone.style.display = "none";
        dragCounter = 0;
        const files = event.dataTransfer.files;
        
        // Remove visual feedback
        const uploadArea = document.querySelector('.upload-area');
        if (uploadArea) {
          uploadArea.classList.remove('dragover');
        }
        
        if (files.length > 0) {
          uploadFiles(files);
        }
      });

      window.addEventListener("dragleave", (event) => {
        if (event.clientX === 0 && event.clientY === 0) {
          dropZone.style.display = "none";
          dragCounter = 0;
        }
      });

      document.addEventListener("dragover", (event) => {
        event.preventDefault();
      });

      textarea.addEventListener("dragover", (event) => {
        event.stopPropagation();
      });

      textarea.addEventListener("drop", (event) => {
        event.stopPropagation();
      });

      function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
      }

      // Function to cancel all active uploads
      async function cancelAllUploads() {
        if (activeUploads.size === 0) {
          showNotification('No active uploads to cancel.', 'info');
          return;
        }
        
        const uploadCount = activeUploads.size;
        const confirmed = await showConfirm(
          `This will cancel ${uploadCount} active upload${uploadCount !== 1 ? 's' : ''}.\n\nFiles will be cleaned up automatically.`,
          'Cancel Uploads',
          'warning'
        );
        
        if (confirmed) {
          console.log(`Canceling ${uploadCount} active uploads...`);
          
          activeUploads.forEach(async (uploadId) => {
            try {
              await fetch(`${environmentPath}/upload/cancel/${uploadId}`, { method: 'DELETE' });
              console.log(`Canceled upload: ${uploadId}`);
            } catch (error) {
              console.error(`Failed to cancel upload ${uploadId}:`, error);
            }
          });
          
          activeUploads.clear();
          
          // Hide progress bars and show cancellation message
          progressContainer.style.display = "none";
          overallProgressBar.style.width = "0%";
          overallPercentage.textContent = "0%";
          chunkProgressBar.style.width = "0%";
          chunkPercentage.textContent = "0%";
          chunkProgressSection.style.display = "none";
          
          showNotification('Uploads canceled successfully. Files will be cleaned up shortly.', 'success');
        }
      }

      function uploadFiles(files) {
        // Check if any files are larger than 45MB (leaving buffer for Cloudflare's 50MB limit)
        const CHUNK_SIZE = 45 * 1024 * 1024; // 45MB chunks
        let hasLargeFiles = false;
        
        for (let file of files) {
          if (file.size > CHUNK_SIZE) {
            hasLargeFiles = true;
            break;
          }
        }
        
        if (hasLargeFiles) {
          uploadLargeFiles(files);
        } else {
          uploadSmallFiles(files);
        }
      }

      // Enhanced upload functions with better UX
      function uploadSmallFiles(files) {
        const formData = new FormData();
        let totalSize = 0;
        
        for (let i = 0; i < files.length; i++) {
          formData.append('files', files[i]);
          totalSize += files[i].size;
        }

        const xhr = new XMLHttpRequest();
        xhr.open("POST", `${environmentPath}/upload`, true);

        xhr.upload.onprogress = function (event) {
          if (event.lengthComputable) {
            const percentComplete = (event.loaded / event.total) * 100;
            overallProgressBar.style.width = percentComplete + "%";
            overallPercentage.textContent = Math.round(percentComplete) + "%";
          }
        };

        xhr.onloadstart = function () {
          progressContainer.style.display = "block";
          progressText.innerHTML = `
            <i class="fas fa-upload" style="margin-right: 8px;"></i>
            Uploading ${files.length} file${files.length !== 1 ? 's' : ''} (${formatFileSize(totalSize)})...
          `;
          chunkProgressSection.style.display = "none";
        };

        xhr.onload = function () {
          if (xhr.status === 200) {
            progressText.innerHTML = `
              <i class="fas fa-check-circle" style="margin-right: 8px; color: var(--success-green);"></i>
              Upload completed successfully!
            `;
            overallProgressBar.classList.add('success');
            showNotification('Files uploaded successfully!', 'success');
          } else {
            progressText.innerHTML = `
              <i class="fas fa-exclamation-circle" style="margin-right: 8px; color: var(--danger-red);"></i>
              Upload failed!
            `;
            showNotification('Upload failed! Please try again.', 'error');
          }
        };

        xhr.onerror = function () {
          progressText.innerHTML = `
            <i class="fas fa-exclamation-triangle" style="margin-right: 8px; color: var(--warning-yellow);"></i>
            Network error during upload!
          `;
          showNotification('Network error! Check your connection.', 'error');
        };

        xhr.onloadend = function () {
          setTimeout(() => {
            progressContainer.style.display = "none";
            overallProgressBar.style.width = "0%";
            overallPercentage.textContent = "0%";
            progressText.textContent = "";
            overallProgressBar.classList.remove('success');
          }, 2000);
          socket.emit("fileUpdate");
        };

        xhr.send(formData);
      }

      async function uploadLargeFiles(files) {
        const CHUNK_SIZE = 45 * 1024 * 1024; // 45MB chunks
        progressContainer.style.display = "block";
        chunkProgressSection.style.display = "block";
        
        try {
          let totalProgress = 0;
          const totalFiles = files.length;
          
          for (let i = 0; i < files.length; i++) {
            const file = files[i];
            const fileProgress = `File ${i + 1}/${totalFiles}: `;
            
            if (file.size > CHUNK_SIZE) {
              progressText.textContent = `${fileProgress}Uploading "${file.name}" (${formatFileSize(file.size)})`;
              await uploadFileInChunks(file, CHUNK_SIZE, i, totalFiles);
            } else {
              progressText.textContent = `${fileProgress}Uploading "${file.name}" (${formatFileSize(file.size)})`;
              chunkProgressSection.style.display = "none";
              await uploadSingleFile(file);
              
              // Update overall progress for small files
              totalProgress = ((i + 1) / totalFiles) * 100;
              overallProgressBar.style.width = totalProgress + "%";
              overallPercentage.textContent = Math.round(totalProgress) + "%";
            }
          }
          
          progressText.textContent = "‚úÖ All uploads completed successfully!";
          overallProgressBar.style.width = "100%";
          overallPercentage.textContent = "100%";
          chunkProgressSection.style.display = "none";
          
          setTimeout(() => {
            progressText.textContent = "";
          }, 2000);
        } catch (error) {
          console.error('Upload failed:', error);
          progressText.textContent = "‚ùå Upload failed!";
          chunkProgressSection.style.display = "none";
          
          // Cancel any active uploads on error
          activeUploads.forEach(uploadId => {
            fetch(`/upload/cancel/${uploadId}`, { method: 'DELETE' })
              .catch(err => console.log('Failed to cancel upload after error:', err));
          });
          activeUploads.clear();
          
          alert('Upload failed: ' + error.message);
          setTimeout(() => {
            progressText.textContent = "";
          }, 3000);
        } finally {
          setTimeout(() => {
            progressContainer.style.display = "none";
            overallProgressBar.style.width = "0%";
            overallPercentage.textContent = "0%";
            chunkProgressBar.style.width = "0%";
            chunkPercentage.textContent = "0%";
          }, 2000);
          socket.emit("fileUpdate");
        }
      }

      async function uploadSingleFile(file) {
        const formData = new FormData();
        formData.append('files', file);

        return new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          xhr.open("POST", `${environmentPath}/upload`, true);

          xhr.onload = function () {
            if (xhr.status === 200) {
              resolve();
            } else {
              reject(new Error(`Failed to upload ${file.name}`));
            }
          };

          xhr.onerror = function () {
            reject(new Error(`Network error uploading ${file.name}`));
          };

          xhr.send(formData);
        });
      }

      async function uploadFileInChunks(file, chunkSize, fileIndex, totalFiles) {
        const totalChunks = Math.ceil(file.size / chunkSize);
        
        // Initiate upload session
        const initResponse = await fetch(`${environmentPath}/upload/initiate`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            fileName: file.name,
            fileSize: file.size,
            totalChunks: totalChunks
          })
        });

        if (!initResponse.ok) {
          const errorText = await initResponse.text();
          console.error('Initiate upload error:', errorText);
          throw new Error(`Failed to initiate upload for ${file.name}: ${errorText}`);
        }

        const { uploadId } = await initResponse.json();
        
        // Track this upload for cleanup
        activeUploads.add(uploadId);
        
        // Upload chunks sequentially with progress tracking
        for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
          const start = chunkIndex * chunkSize;
          const end = Math.min(start + chunkSize, file.size);
          const chunk = file.slice(start, end);
          
          // Update chunk progress info
          chunkLabel.textContent = `Chunk ${chunkIndex + 1} of ${totalChunks} (${formatFileSize(chunk.size)})`;
          chunkProgressBar.style.width = "0%";
          chunkPercentage.textContent = "0%";
          
          const formData = new FormData();
          formData.append('uploadId', uploadId);
          formData.append('chunkIndex', chunkIndex);
          formData.append('chunk', chunk);

          // Create XMLHttpRequest for progress tracking
          await new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            
            xhr.upload.onprogress = function(event) {
              if (event.lengthComputable) {
                const chunkProgress = (event.loaded / event.total) * 100;
                chunkProgressBar.style.width = chunkProgress + "%";
                chunkPercentage.textContent = Math.round(chunkProgress) + "%";
                
                // Calculate overall progress
                const completedChunks = chunkIndex;
                const currentChunkProgress = chunkProgress / 100;
                const fileProgress = (completedChunks + currentChunkProgress) / totalChunks;
                const totalProgress = ((fileIndex + fileProgress) / totalFiles) * 100;
                
                overallProgressBar.style.width = totalProgress + "%";
                overallPercentage.textContent = Math.round(totalProgress) + "%";
              }
            };
            
            xhr.onload = function() {
              if (xhr.status === 200) {
                // Chunk upload completed
                chunkProgressBar.style.width = "100%";
                chunkPercentage.textContent = "100%";
                resolve();
              } else {
                reject(new Error(`Failed to upload chunk ${chunkIndex + 1}/${totalChunks} for ${file.name}`));
              }
            };
            
            xhr.onerror = function() {
              reject(new Error(`Network error uploading chunk ${chunkIndex + 1}/${totalChunks} for ${file.name}`));
            };
            
            xhr.open('POST', `${environmentPath}/upload/chunk`);
            xhr.send(formData);
          });
          
          // Brief pause between chunks for better visual feedback
          await new Promise(resolve => setTimeout(resolve, 100));
        }

        // Complete upload
        progressText.textContent = progressText.textContent.replace(/Uploading/, 'Finalizing');
        chunkLabel.textContent = "Combining chunks...";
        chunkProgressBar.style.width = "100%";
        chunkPercentage.textContent = "100%";
        
        const completeResponse = await fetch(`${environmentPath}/upload/complete`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ uploadId })
        });

        if (!completeResponse.ok) {
          const errorText = await completeResponse.text();
          console.error('Complete upload error:', errorText);
          throw new Error(`Failed to complete upload for ${file.name}: ${errorText}`);
        }
        
        // Remove from active uploads when completed successfully
        activeUploads.delete(uploadId);
        
        // Force a file update to refresh the list
        socket.emit("fileUpdate");
      }

      // Enhanced delete event listeners with better UX
      function attachDeleteEventListeners() {
        const deleteButtons = document.querySelectorAll(".delete-button");
        deleteButtons.forEach((button) => {
          button.addEventListener("click", async (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            const fileItem = button.closest("[data-filename]");
            const filename = fileItem.getAttribute("data-filename");

            const confirmed = await showConfirm(
              `This will permanently delete "${filename}".\n\nThis action cannot be undone.`,
              'Delete File',
              'danger'
            );
            
            if (confirmed) {
              // Show loading state
              const originalHTML = button.innerHTML;
              button.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
              button.disabled = true;
              
              fetch(`${environmentPath}/files/${filename}`, {
                method: "DELETE",
              })
              .then((response) => {
                if (response.ok) {
                  // Simple fade out for VNC compatibility
                  fileItem.style.opacity = '0.3';
                  setTimeout(() => {
                    fileItem.remove();
                    updateFileCounts();
                  }, 300);
                  
                  socket.emit("fileUpdate");
                  showNotification(`"${filename}" deleted successfully`, 'success');
                } else {
                  button.innerHTML = originalHTML;
                  button.disabled = false;
                  showNotification(`Failed to delete "${filename}"`, 'error');
                }
              })
              .catch((error) => {
                console.error("Delete error:", error);
                button.innerHTML = originalHTML;
                button.disabled = false;
                showNotification(`Error deleting "${filename}"`, 'error');
              });
            }
          });
        });
      }

      // Enhanced resizer with better performance for VNC
      let isResizing = false;
      
      resizer.addEventListener("mousedown", function (e) {
        e.preventDefault();
        isResizing = true;
        document.addEventListener("mousemove", resize);
        document.addEventListener("mouseup", stopResize);
        document.body.style.cursor = 'ew-resize';
        document.body.style.userSelect = 'none';
      });

      function resize(e) {
        if (!isResizing) return;
        
        const minWidth = 300;
        const maxWidth = Math.min(600, window.innerWidth * 0.6);
        const newWidth = Math.max(minWidth, Math.min(maxWidth, e.clientX));
        sidebar.style.width = newWidth + "px";
      }

      function stopResize() {
        isResizing = false;
        document.removeEventListener("mousemove", resize);
        document.removeEventListener("mouseup", stopResize);
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
      }

      // Clipboard paste functionality for images
      document.addEventListener('paste', async function(e) {
        const clipboardItems = e.clipboardData.items;
        
        for (let i = 0; i < clipboardItems.length; i++) {
          const item = clipboardItems[i];
          
          // Check if the item is an image
          if (item.type.indexOf('image') !== -1) {
            e.preventDefault();
            
            const blob = item.getAsFile();
            if (blob) {
              // Check file size before processing (50MB limit)
              const maxSize = 50 * 1024 * 1024; // 50MB in bytes
              if (blob.size > maxSize) {
                showNotification('‚ùå Image too large. Maximum size is 50MB.', 'error');
                return;
              }
              
              console.log('Processing pasted image:', {
                type: blob.type,
                size: blob.size,
                sizeFormatted: formatFileSize(blob.size)
              });
              
              // Convert blob to base64
              const reader = new FileReader();
              reader.onload = async function(event) {
                const base64Data = event.target.result;
                
                console.log('Base64 data length:', base64Data.length);
                
                try {
                  showNotification('üìã Uploading pasted image...', 'info');
                  
                  // Use root endpoint for better compatibility
                  const pasteUrl = environmentPath ? `${environmentPath}/paste-image` : '/paste-image';
                  
                  const response = await fetch(pasteUrl, {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                      imageData: base64Data
                    })
                  });
                  
                  if (response.ok) {
                    const result = await response.json();
                    showNotification(`‚úÖ Image pasted successfully as "${result.filename}"`, 'success');
                    socket.emit("fileUpdate");
                  } else {
                    // Handle both JSON and HTML error responses
                    let errorMessage = `HTTP ${response.status}`;
                    try {
                      const errorData = await response.json();
                      errorMessage = errorData.error || errorMessage;
                    } catch (jsonError) {
                      // If response is not JSON, try to get text
                      try {
                        const errorText = await response.text();
                        if (errorText.includes('413') || errorText.includes('Payload Too Large')) {
                          errorMessage = 'Image too large. Please try a smaller image.';
                        } else {
                          errorMessage = `Server error (${response.status})`;
                        }
                      } catch (textError) {
                        errorMessage = `Server error (${response.status})`;
                      }
                    }
                    console.error('Paste image error:', errorMessage);
                    showNotification(`‚ùå Failed to paste image: ${errorMessage}`, 'error');
                  }
                  
                } catch (error) {
                  console.error('Error uploading pasted image:', error);
                  showNotification('‚ùå Network error while uploading image', 'error');
                }
              };
              
              reader.readAsDataURL(blob);
            }
            break; // Only handle the first image
          }
        }
      });



      // Enhanced file icon detection to show thumbnails for images
      function getFileIcon(filename, isImage = false) {
        const ext = filename.split('.').pop().toLowerCase();
        
        if (isImage) {
          return 'fas fa-image'; // Use image icon for all images
        }
        
        const iconMap = {
          // Documents
          'pdf': 'fas fa-file-pdf',
          'doc': 'fas fa-file-word', 'docx': 'fas fa-file-word',
          'xls': 'fas fa-file-excel', 'xlsx': 'fas fa-file-excel',
          'ppt': 'fas fa-file-powerpoint', 'pptx': 'fas fa-file-powerpoint',
          'txt': 'fas fa-file-alt', 'md': 'fas fa-file-alt',
          
          // Code
          'js': 'fas fa-file-code', 'ts': 'fas fa-file-code',
          'html': 'fas fa-file-code', 'css': 'fas fa-file-code',
          'json': 'fas fa-file-code', 'xml': 'fas fa-file-code',
          'py': 'fas fa-file-code', 'java': 'fas fa-file-code',
          'cpp': 'fas fa-file-code', 'c': 'fas fa-file-code',
          
          // Archives
          'zip': 'fas fa-file-archive', 'rar': 'fas fa-file-archive',
          '7z': 'fas fa-file-archive', 'tar': 'fas fa-file-archive',
          'gz': 'fas fa-file-archive',
          
          // Media
          'mp3': 'fas fa-file-audio', 'wav': 'fas fa-file-audio',
          'mp4': 'fas fa-file-video', 'avi': 'fas fa-file-video',
          'mov': 'fas fa-file-video', 'wmv': 'fas fa-file-video'
        };
        
        return iconMap[ext] || 'fas fa-file';
      }

      // Keyboard shortcuts
      document.addEventListener('keydown', function(e) {
        // Ctrl/Cmd + U for upload
        if ((e.ctrlKey || e.metaKey) && e.key === 'u') {
          e.preventDefault();
          fileInput.click();
        }
        
        // Ctrl/Cmd + K for clear
        if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
          e.preventDefault();
          clearClipboard();
        }
        
        // Ctrl/Cmd + V for paste (hint for users)
        if ((e.ctrlKey || e.metaKey) && e.key === 'v' && e.target === document.body) {
          showNotification('üí° Tip: You can paste images directly anywhere on this page!', 'info');
        }
        
        // ESC to cancel uploads
        if (e.key === 'Escape' && activeUploads.size > 0) {
          cancelAllUploads();
        }
      });

      // Initialize everything when DOM is loaded
      document.addEventListener('DOMContentLoaded', function() {
        initializeApp();
        attachDeleteEventListeners();
        updateFileCounts();
        updateFileIcons();
        setupImageThumbnails();
      });

      // Initialize immediately since we're in the document
      initializeApp();
      attachDeleteEventListeners();
      updateFileCounts();
      updateFileIcons();
      setupImageThumbnails();
    </script>
  </body>
</html>
