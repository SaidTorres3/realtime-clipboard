<!DOCTYPE html>
<html class="h-full" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title><% if (typeof environmentName !== 'undefined' && environmentName && environmentName !== 'default') { %><%= environmentName %> - RealTime-Clipboard<% } else { %>RealTime-Clipboard<% } %></title>
    <script src="/socket.io/socket.io.js"></script>
    <link href="tailwind.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500;600&display=swap" rel="stylesheet" />
    <link href="/styles.css" rel="stylesheet" />
    <!-- inline styles moved to views/styles.css -->
  </head>

  <body>
    <!-- Main Container -->
    <div class="flex main-container" style="min-height: 100%;">
      <!-- Sidebar -->
      <div class="sidebar">
        <div class="sidebar-content">
          <!-- Environment Switcher Button (Mobile Only) -->
          <button class="env-switch-btn mobile-only" onclick="showEnvironmentSwitcher()" title="Switch Environment">
            <i class="fas fa-exchange-alt"></i>
            <span>Switch Environment</span>
          </button>

          <!-- Environment Badge -->
          <% if (typeof environmentName !== 'undefined' && environmentName !== 'default') { %>
          <div class="environment-badge">
            <div class="environment-label">Environment</div>
            <div class="environment-name"><%= environmentName %></div>
          </div>
          <% } %>

          <!-- Upload Section -->
          <div class="sidebar-section">
            <h3 class="section-title">
              <i class="fas fa-cloud-upload-alt"></i>
              File Upload
            </h3>
            
            <form id="upload-form" action="<%= typeof environmentPath !== 'undefined' ? environmentPath : '' %>/upload" method="post" enctype="multipart/form-data">
              <div class="upload-area" onclick="document.getElementById('file-input').click()">
                <div class="upload-icon">
                  <i class="fas fa-plus-circle"></i>
                </div>
                <div class="upload-text">Drop files here or click to browse</div>
                <div class="upload-subtext">Files upload automatically â€¢ Supports multiple files and large uploads</div>
                <input
                  id="file-input"
                  type="file"
                  name="files"
                  multiple
                  style="display: none;"
                />
              </div>
            </form>

            <!-- Inline Progress Section -->
            <div id="inline-progress-container" style="display: none; margin-top: 20px;">
              <div class="progress-card">
                <div id="progress-text" class="progress-label mb-2">
                  <i class="fas fa-spinner fa-spin" style="margin-right: 8px;"></i>
                  Processing...
                </div>
                
                <!-- Overall Progress -->
                <div class="progress-section">
                  <div class="progress-header">
                    <span class="progress-label">Overall Progress</span>
                    <span id="overall-percentage" class="progress-percentage">0%</span>
                  </div>
                  <div class="progress-track">
                    <div id="overall-progress-bar" class="progress-bar" style="width: 0%"></div>
                  </div>
                </div>
                
                <!-- Current Chunk Progress -->
                <div id="chunk-progress-section" style="display: none;" class="progress-section">
                  <div class="progress-header">
                    <span class="progress-label" id="chunk-label">Current Chunk</span>
                    <div class="flex items-center gap-2">
                      <span id="chunk-percentage" class="progress-percentage">0%</span>
                      <button 
                        id="cancel-upload-btn" 
                        class="btn btn-danger"
                        style="padding: 4px 8px; font-size: 11px;"
                        onclick="cancelAllUploads()"
                        title="Cancel upload"
                      >
                        <i class="fas fa-times"></i>
                      </button>
                    </div>
                  </div>
                  <div class="progress-track">
                    <div id="chunk-progress-bar" class="progress-bar" style="width: 0%"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Files Section -->
          <div class="sidebar-section flex-1">
            <div class="flex items-center justify-between mb-4">
              <h3 class="section-title">
                <i class="fas fa-folder-open"></i>
                Shared Files
              </h3>
              <span id="file-count" class="stat-value"><%= files.length %></span>
            </div>
            
            <div class="file-list" id="file-list">
              <% if (files.length === 0) { %>
              <div style="text-align: center; padding: 0px 20px; color: var(--text-muted);">
                <i class="fas fa-folder-open" style="font-size: 48px; margin-bottom: 15px; display: block; opacity: 0.5;"></i>
                <p>No files uploaded yet</p>
                <p style="font-size: 12px; margin-top: 8px;">ðŸ’¡ Paste images directly with Ctrl+V</p>
              </div>
              <% } else { %>
                <% files.forEach(file => { 
                  const fileName = typeof file === 'string' ? file.name || file : file.originalFileName;
                  const isImage = typeof file === 'object' ? (file.isImageFile || file.isImage) : false;
                  const isText = typeof file === 'object' ? file.isTextFile : false;
                  // Check isPDFFile property first, then fall back to file extension check for older files
                  const isPDF = typeof file === 'object' ? (file.isPDFFile || (fileName && fileName.toLowerCase().endsWith('.pdf'))) : false;
                  // Check isVideoFile property
                  const isVideo = typeof file === 'object' ? file.isVideoFile : false;
                  const totalVersions = typeof file === 'object' ? file.totalVersions : 1;
                  const hasMultipleVersions = totalVersions > 1;
                  
                  // Extract upload date and file size from current version or file stats
                  let uploadDate = 'Unknown';
                  let fileSize = '';
                  if (typeof file === 'object' && file.currentVersion) {
                    const date = new Date(file.currentVersion.uploadedAt);
                    uploadDate = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    
                    // Format file size
                    const bytes = file.currentVersion.fileSize;
                    if (bytes === 0) {
                      fileSize = '0 Bytes';
                    } else {
                      const k = 1024;
                      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                      const i = Math.floor(Math.log(bytes) / Math.log(k));
                      fileSize = parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                    }
                  } else if (typeof file === 'object' && file.lastModified) {
                    const date = new Date(file.lastModified);
                    uploadDate = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    
                    // Format file size from size property
                    if (file.size !== undefined) {
                      const bytes = file.size;
                      if (bytes === 0) {
                        fileSize = '0 Bytes';
                      } else {
                        const k = 1024;
                        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                        const i = Math.floor(Math.log(bytes) / Math.log(k));
                        fileSize = parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                      }
                    }
                  }
                %>
                <div class="file-item <%= isImage ? 'has-image' : '' %> <%= isText ? 'has-text' : '' %> <%= isPDF ? 'has-pdf' : '' %> <%= isVideo ? 'has-video' : '' %> <%= hasMultipleVersions ? 'has-versions' : '' %>" 
                     data-filename="<%= fileName %>" 
                     data-versions="<%= totalVersions %>">
                  <div class="file-info">
                    <% if (isImage) { %>
                      <div class="image-thumbnail" 
                           data-image-url="<%= typeof environmentPath !== 'undefined' ? environmentPath : '' %>/files/<%= fileName %>"
                           data-filename="<%= fileName %>">
                        <img src="<%= typeof environmentPath !== 'undefined' ? environmentPath : '' %>/files/<%= fileName %>" 
                             alt="<%= fileName %>" 
                             class="thumbnail-img"
                             loading="lazy" />
                        <div class="image-overlay">
                          <i class="fas fa-search-plus"></i>
                        </div>
                      </div>
                    <% } else if (isText) { %>
                      <div class="text-preview-icon" 
                           data-preview-url="<%= typeof environmentPath !== 'undefined' ? environmentPath : '' %>/files/<%= fileName %>/preview"
                           data-filename="<%= fileName %>">
                        <div class="text-icon">
                          <i class="fas fa-file-alt"></i>
                        </div>
                        <div class="text-overlay">
                          <i class="fas fa-eye"></i>
                        </div>
                      </div>
                    <% } else if (isPDF) { %>
                      <div class="pdf-preview-icon" 
                           data-pdf-url="<%= typeof environmentPath !== 'undefined' ? environmentPath : '' %>/files/<%= fileName %>/pdf-preview"
                           data-filename="<%= fileName %>">
                        <div class="pdf-icon-text">PDF</div>
                        <div class="pdf-overlay">
                          <i class="fas fa-eye"></i>
                        </div>
                      </div>
                    <% } else if (isVideo) { %>
                      <div class="video-preview-icon" 
                           data-video-url="<%= typeof environmentPath !== 'undefined' ? environmentPath : '' %>/files/<%= fileName %>"
                           data-filename="<%= fileName %>">
                        <div class="video-icon-text">â–¶</div>
                        <div class="video-overlay">
                          <i class="fas fa-play"></i>
                        </div>
                      </div>
                    <% } else { %>
                      <div class="file-icon">
                        <i class="fas fa-file" id="file-icon-<%= fileName.replace(/[^a-zA-Z0-9]/g, '') %>"></i>
                      </div>
                    <% } %>
                    <div class="file-details">
                      <a
                        href="<%= typeof environmentPath !== 'undefined' ? environmentPath : '' %>/files/<%= fileName %>"
                        download
                        class="file-name"
                        title="<%= fileName %>"
                      >
                        <%= fileName %>
                      </a>
                      <div class="file-metadata">
                        <span class="file-date">
                          <i class="fas fa-clock"></i>
                          <%= uploadDate %>
                        </span>
                        <% if (fileSize) { %>
                        <span class="file-size"><%= fileSize %></span>
                        <% } %>
                      </div>
                      <% if (hasMultipleVersions) { %>
                      <div class="version-info">
                        <i class="fas fa-history"></i>
                        <span class="version-count"><%= totalVersions %> versions</span>
                        <button class="btn-versions" onclick="showVersions('<%= fileName %>')" title="View all versions">
                          <i class="fas fa-chevron-down"></i>
                        </button>
                      </div>
                      <% } %>
                    </div>
                  </div>
                  <div class="file-actions">
                    <% if (hasMultipleVersions) { %>
                    <button
                      type="button"
                      class="versions-button btn btn-secondary"
                      style="padding: 8px 12px; font-size: 12px; margin-right: 8px;"
                      title="Manage versions"
                      onclick="showVersions('<%= fileName %>')"
                    >
                      <i class="fas fa-history"></i>
                    </button>
                    <% } %>
                    <button
                      type="button"
                      class="delete-button btn btn-danger"
                      style="padding: 8px 12px; font-size: 12px;"
                      title="Delete file"
                    >
                      <i class="fas fa-trash"></i>
                    </button>
                  </div>
                </div>
                <% }) %>
              <% } %>
            </div>
          </div>
        </div>
        <div class="resizer"></div>
      </div>

      <!-- Main Content Area -->
      <div class="content-area">
        <!-- Main Editor -->
        <div class="main-editor">
          <div class="editor-wrapper">
            <div class="editor-header">
              <div class="editor-title">
                <i class="fas fa-keyboard"></i>
                Live Editor
              </div>
              <div class="flex items-center gap-2">
                <button class="env-switch-btn" onclick="showEnvironmentSwitcher()" title="Switch Environment">
                  <i class="fas fa-exchange-alt"></i>
                  <span class="env-switch-text">Switch Env</span>
                </button>
                <div class="connection-status">
                  <div class="status-dot"></div>
                  <span>Connected</span>
                </div>
                <button class="clear-btn" onclick="clearClipboard()" title="Clear all content">
                  <i class="fas fa-eraser"></i>
                  Clear
                </button>
              </div>
            </div>
            <textarea
              id="textarea"
              placeholder="ðŸš€ Welcome to RealTime Clipboard 2.0!

Start typing your shared content here...

âœ¨ Features:
â€¢ Real-time synchronization across all connected devices
â€¢ File sharing with drag & drop support
â€¢ Large file upload with chunked processing
â€¢ Clean, performance-optimized design
â€¢ Different environments (use /any-url-you-want in URL to create/join)

ðŸ’¡ Tips:
â€¢ Use Ctrl/Cmd + A to select all text
â€¢ Drag files directly into the sidebar to upload
â€¢ Hold Alt while clicking Delete to skip confirmation
â€¢ Content is automatically saved and synced
â€¢ In case of disaster, wait 10 seconds and use Ctrl + Alt + Z to undo changes or Ctrl + Alt + Y to redo changes
"
            ></textarea>
          </div>
        </div>
      </div>
    </div>



    <!-- Drop Zone -->
    <div id="drop-zone">
      <div class="drop-zone-content">
        <div class="drop-zone-icon">
          <i class="fas fa-cloud-upload-alt"></i>
        </div>
        <div class="drop-zone-title">Drop Files Here</div>
        <div class="drop-zone-text">Release to upload your files instantly</div>
      </div>
    </div>

    <!-- Custom Confirmation Dialog -->
    <div id="confirm-overlay" class="confirm-overlay">
      <div class="confirm-dialog">
        <div class="confirm-header">
          <div id="confirm-icon" class="confirm-icon">
            <i class="fas fa-question-circle"></i>
          </div>
          <h3 id="confirm-title" class="confirm-title">Confirm Action</h3>
        </div>
        <div id="confirm-message" class="confirm-message">
          Are you sure you want to proceed?
        </div>
        <div class="confirm-buttons">
          <button id="confirm-cancel" class="confirm-btn secondary">Cancel</button>
          <button id="confirm-ok" class="confirm-btn primary">Confirm</button>
        </div>
      </div>
    </div>

    <!-- Environment Switcher Modal -->
    <div id="env-switcher-overlay" class="confirm-overlay">
      <div class="confirm-dialog env-switcher-dialog">
        <div class="confirm-header">
          <div class="confirm-icon" style="background: linear-gradient(135deg, var(--primary-blue), var(--accent-light-blue));">
            <i class="fas fa-exchange-alt"></i>
          </div>
          <h3 class="confirm-title">Switch Environment</h3>
        </div>
        <div class="env-switcher-body">
          <p class="env-switcher-description">Enter the name of the environment you want to switch to:</p>
          <div class="env-input-wrapper">
            <input 
              type="text" 
              id="env-name-input" 
              class="env-name-input" 
              placeholder="e.g., project-name, team-workspace"
              autocomplete="off"
            />
            <div class="env-input-hint">
              <i class="fas fa-info-circle"></i>
              Leave empty for default environment
            </div>
          </div>
          <div class="env-current">
            <i class="fas fa-map-marker-alt"></i>
            <span>Current: <strong id="current-env-name">default</strong></span>
          </div>
        </div>
        <div class="confirm-buttons">
          <button id="env-cancel-btn" class="confirm-btn secondary">Cancel</button>
          <button id="env-switch-btn" class="confirm-btn primary">
            <i class="fas fa-arrow-right"></i>
            Switch
          </button>
        </div>
      </div>
    </div>

    <!-- Image Preview Modal -->
    <div id="image-modal" class="image-modal">
      <div class="modal-content">
        <button class="modal-close" onclick="closeImageModal()">Ã—</button>
        <img id="modal-image" class="modal-image" src="" alt="">
        <div id="modal-filename" class="modal-filename"></div>
      </div>
    </div>

    <!-- Text Preview Modal -->
    <div id="text-modal" class="image-modal">
      <div class="modal-content text-modal-content">
        <button class="modal-close" onclick="closeTextModal()">Ã—</button>
        <div class="text-modal-header">
          <div id="text-modal-filename" class="modal-filename"></div>
          <div id="text-modal-info" class="text-modal-info"></div>
        </div>
        <div class="text-modal-body">
          <pre id="text-modal-content" class="text-content"></pre>
        </div>
      </div>
    </div>

    <!-- PDF Preview Modal -->
    <div id="pdf-modal" class="image-modal">
      <div class="modal-content pdf-modal-content">
        <button class="modal-close" onclick="closePDFModal()">Ã—</button>
        <div class="pdf-modal-header">
          <div id="pdf-modal-filename" class="modal-filename"></div>
          <div id="pdf-modal-info" class="pdf-modal-info"></div>
        </div>
        <div class="pdf-modal-body">
          <iframe id="pdf-modal-iframe" class="pdf-viewer"></iframe>
        </div>
      </div>
    </div>

    <!-- Video Preview Modal -->
    <div id="video-modal" class="image-modal">
      <div class="modal-content video-modal-content">
        <button class="modal-close" onclick="closeVideoModal()">Ã—</button>
        <div class="video-modal-header">
          <div id="video-modal-filename" class="modal-filename"></div>
          <div id="video-modal-info" class="video-modal-info"></div>
        </div>
        <div class="video-modal-body">
          <video id="video-modal-player" class="video-player" controls>
            Your browser does not support the video tag.
          </video>
        </div>
      </div>
    </div>

    <!-- Version Management Modal -->
    <div id="version-modal" class="image-modal">
      <div class="modal-content" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
        <button class="modal-close" onclick="closeVersionModal()">Ã—</button>
        <div id="version-modal-content">
          <h3 id="version-modal-title" style="color: var(--text-primary); margin-bottom: 20px; display: flex; align-items: center; gap: 10px;">
            <i class="fas fa-history"></i>
            File Versions
          </h3>
          <div id="version-list" class="version-list">
            <!-- Version items will be populated here -->
          </div>
        </div>
      </div>
    </div>

    <script>
      const socket = io();
      const textarea = document.getElementById("textarea");
      const fileList = document.getElementById("file-list");
      const dropZone = document.getElementById("drop-zone");
      const fileInput = document.getElementById("file-input");
      const uploadForm = document.getElementById("upload-form");
      const resizer = document.querySelector(".resizer");
      const sidebar = document.querySelector(".sidebar");
      const progressContainer = document.getElementById("inline-progress-container");
      const progressText = document.getElementById("progress-text");
      const overallProgressBar = document.getElementById("overall-progress-bar");
      const overallPercentage = document.getElementById("overall-percentage");
      const chunkProgressSection = document.getElementById("chunk-progress-section");
      const chunkProgressBar = document.getElementById("chunk-progress-bar");
      const chunkPercentage = document.getElementById("chunk-percentage");
      const chunkLabel = document.getElementById("chunk-label");
      const fileCount = document.getElementById("file-count");
      const filesCount = document.getElementById("files-count");
      const usersCount = document.getElementById("users-count");
      const connectionStatusEl = document.querySelector('.connection-status');
      const statusDotEl = connectionStatusEl ? connectionStatusEl.querySelector('.status-dot') : null;
      const statusLabelEl = connectionStatusEl ? connectionStatusEl.querySelector('span') : null;

      // Local Storage Version Control System
      class LocalVersionControl {
        constructor(environmentName, maxVersions = 35, saveDelay = 10000) {
          this.storageKey = `rtc_versions_${environmentName}`;
          this.maxVersions = maxVersions;
          this.saveDelay = saveDelay;
          this.saveTimeout = null;
          this.currentIndex = -1;
          this.versions = this.loadVersions();
          this.isNavigating = false; // Flag to prevent saving during navigation
        }

        loadVersions() {
          try {
            const stored = localStorage.getItem(this.storageKey);
            if (stored) {
              const data = JSON.parse(stored);
              this.currentIndex = data.currentIndex || -1;
              return data.versions || [];
            }
          } catch (error) {
            console.error('Error loading versions from localStorage:', error);
          }
          return [];
        }

        saveToStorage() {
          try {
            localStorage.setItem(this.storageKey, JSON.stringify({
              versions: this.versions,
              currentIndex: this.currentIndex
            }));
          } catch (error) {
            console.error('Error saving versions to localStorage:', error);
            // If quota exceeded, remove oldest versions and retry
            if (error.name === 'QuotaExceededError') {
              this.versions = this.versions.slice(-Math.floor(this.maxVersions / 2));
              this.currentIndex = Math.min(this.currentIndex, this.versions.length - 1);
              try {
                localStorage.setItem(this.storageKey, JSON.stringify({
                  versions: this.versions,
                  currentIndex: this.currentIndex
                }));
              } catch (retryError) {
                console.error('Failed to save even after cleanup:', retryError);
              }
            }
          }
        }

        scheduleAutoSave(text) {
          // Don't auto-save during navigation
          if (this.isNavigating) {
            return;
          }

          // Clear existing timeout
          if (this.saveTimeout) {
            clearTimeout(this.saveTimeout);
          }

          // Schedule new save
          this.saveTimeout = setTimeout(() => {
            this.saveVersion(text);
          }, this.saveDelay);
        }

        saveVersion(text) {
          // Don't save during navigation
          if (this.isNavigating) {
            return;
          }

          // Don't save if text is the same as the current version
          if (this.currentIndex >= 0 && this.versions[this.currentIndex] === text) {
            return;
          }

          // If we're not at the end of the history, remove all versions after current position
          if (this.currentIndex < this.versions.length - 1) {
            this.versions = this.versions.slice(0, this.currentIndex + 1);
          }

          // Add new version
          this.versions.push(text);
          this.currentIndex = this.versions.length - 1;

          // Trim to max versions
          if (this.versions.length > this.maxVersions) {
            const removeCount = this.versions.length - this.maxVersions;
            this.versions = this.versions.slice(removeCount);
            this.currentIndex = this.versions.length - 1;
          }

          this.saveToStorage();
          console.log(`Version saved. Total versions: ${this.versions.length}, Current index: ${this.currentIndex}`);
        }

        canUndo() {
          return this.currentIndex > 0;
        }

        canRedo() {
          return this.currentIndex < this.versions.length - 1;
        }

        undo() {
          if (this.canUndo()) {
            this.isNavigating = true;
            this.currentIndex--;
            this.saveToStorage();
            const version = this.versions[this.currentIndex];
            console.log(`Undo to version ${this.currentIndex + 1}/${this.versions.length}`);
            return version;
          }
          return null;
        }

        redo() {
          if (this.canRedo()) {
            this.isNavigating = true;
            this.currentIndex++;
            this.saveToStorage();
            const version = this.versions[this.currentIndex];
            console.log(`Redo to version ${this.currentIndex + 1}/${this.versions.length}`);
            return version;
          }
          return null;
        }

        finishNavigation() {
          this.isNavigating = false;
        }

        getVersionInfo() {
          return {
            current: this.currentIndex + 1,
            total: this.versions.length,
            canUndo: this.canUndo(),
            canRedo: this.canRedo()
          };
        }

        // Initialize with current text if no versions exist
        initialize(text) {
          if (this.versions.length === 0) {
            this.versions.push(text);
            this.currentIndex = 0;
            this.saveToStorage();
          }
        }
      }
      const STATUS_CLASSES = ['online', 'offline', 'reconnecting'];
      const CONNECTION_CONFIG = {
        online: {
          text: 'Connected',
          title: 'Connected to RealTime Clipboard.'
        },
        reconnecting: {
          text: 'Reconnectingâ€¦',
          title: 'Attempting to restore the connectionâ€¦'
        },
        offline: {
          text: 'Offline',
          title: 'No network connection detected.'
        }
      };
      let currentConnectionState = null;
      let skipNextConnectionNotification = false;

      if (connectionStatusEl) {
        connectionStatusEl.setAttribute('role', 'status');
        connectionStatusEl.setAttribute('aria-live', 'polite');
        connectionStatusEl.setAttribute('aria-atomic', 'true');
      }

      function formatConnectionReason(value) {
        if (!value) return '';
        if (typeof value === 'string') return value;
        if (typeof value === 'object') {
          if (value.message) return value.message;
          if (value.description) return value.description;
          if (value.type) return value.type;
          try {
            return JSON.stringify(value);
          } catch (err) {
            return '';
          }
        }
        return String(value);
      }

      function setConnectionStatus(state, options = {}) {
        if (!connectionStatusEl || !statusDotEl || !statusLabelEl) {
          return;
        }

        const { text, reason, silent = false, suppressNext = false } = options;
        const targetState = STATUS_CLASSES.includes(state) ? state : 'online';
        const previousState = currentConnectionState;
        const config = CONNECTION_CONFIG[targetState] || CONNECTION_CONFIG.online;
        currentConnectionState = targetState;
        const suppressNotificationsNow = silent || skipNextConnectionNotification;
        skipNextConnectionNotification = suppressNext;

        STATUS_CLASSES.forEach(cls => {
          connectionStatusEl.classList.remove(cls);
          statusDotEl.classList.remove(cls);
        });

        connectionStatusEl.classList.add(targetState);
        statusDotEl.classList.add(targetState);
        connectionStatusEl.setAttribute('data-status', targetState);

        // Add connection status to body for styling the editor wrapper
        document.body.setAttribute('data-connection-status', targetState);

        statusLabelEl.textContent = text || config.text;

        const reasonText = formatConnectionReason(reason);
        const title = reasonText ? `${config.title} (${reasonText})` : config.title;
        connectionStatusEl.title = title;

        if (suppressNotificationsNow) {
          return;
        }

        if (targetState === 'offline' && previousState !== 'offline') {
          showNotification("âš ï¸ Connection lost. Changes will sync when you're back online.", 'warning');
        } else if (targetState === 'online' && previousState && previousState !== 'online') {
          showNotification('âœ… Reconnected to RealTime Clipboard.', 'success');
        }
      }

  // Check initial connection state - prioritize browser offline detection
  const initialConnectionState = !navigator.onLine ? 'offline' : (socket.connected ? 'online' : 'reconnecting');
  setConnectionStatus(initialConnectionState, { silent: true, suppressNext: true });

      socket.on('connect', async () => {
        // Test actual connection before marking as online
        try {
          const actuallyOnline = await checkRealConnection();
          if (actuallyOnline) {
            setConnectionStatus('online');
          }
        } catch (error) {
          // If connection test fails, stay in reconnecting
          setConnectionStatus('reconnecting');
        }
      });

      socket.on('disconnect', (reason) => {
        const state = navigator.onLine ? 'reconnecting' : 'offline';
        setConnectionStatus(state, { reason });
      });

      socket.on('connect_error', (error) => {
        const state = navigator.onLine ? 'reconnecting' : 'offline';
        setConnectionStatus(state, { reason: error });
      });

      if (socket.io) {
        socket.io.on('reconnect_attempt', (attempt) => {
          setConnectionStatus('reconnecting', { reason: `Attempt ${attempt}`, silent: true });
        });

        socket.io.on('reconnect', () => {
          setConnectionStatus('online');
        });

        socket.io.on('reconnect_error', (error) => {
          const state = navigator.onLine ? 'reconnecting' : 'offline';
          setConnectionStatus(state, { reason: error, silent: true });
        });

        socket.io.on('reconnect_failed', () => {
          setConnectionStatus('offline', { reason: 'Unable to reach server' });
        });
      }

      window.addEventListener('online', () => {
        if (socket.disconnected) {
          socket.connect();
        }
        setConnectionStatus(socket.connected ? 'online' : 'reconnecting', { silent: true });
      });

      window.addEventListener('offline', () => {
        setConnectionStatus('offline', { reason: 'Browser offline' });
      });

      // Aggressive network detection for mobile devices
      // Actually test the connection by making a request
      async function checkRealConnection() {
        try {
          const controller = new AbortController();
          
          // Create a timeout promise (2 seconds - balance between speed and slow connections)
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => {
              controller.abort();
              reject(new Error('Connection timeout'));
            }, 3000); // 2 seconds - works with slow 3G/4G but still fast enough
          });
          
          // Race between fetch and timeout
          const fetchPromise = fetch('/ping', {
            method: 'HEAD',
            cache: 'no-cache',
            signal: controller.signal
          });
          
          const response = await Promise.race([fetchPromise, timeoutPromise]);
          return response.ok;
        } catch (error) {
          // Timeout or network error - consider offline
          return false;
        }
      }

      // Check connection status every second - AGGRESSIVE MODE
      let isCheckingConnection = false; // Prevent overlapping checks
      let consecutiveChecks = 0;
      
      setInterval(async () => {
        if (isCheckingConnection) {
          return;
        }
        
        const isOnline = navigator.onLine;
        const socketConnected = socket.connected;
        
        // If navigator says offline, trust it immediately without testing
        if (!isOnline && currentConnectionState !== 'offline') {
          setConnectionStatus('offline', { reason: 'Network unavailable', silent: true });
          return;
        }
        
        // Check connection every 3 seconds (skip 2 out of 3 checks when stable)
        consecutiveChecks++;
        const shouldCheck = 
          currentConnectionState === 'offline' || // Always check if offline (to detect recovery)
          !socketConnected || // Always check if socket down
          currentConnectionState === 'reconnecting' || // Always check if reconnecting
          consecutiveChecks >= 3; // Check every 3 seconds when stable
        
        if (!shouldCheck) {
          return;
        }
        
        if (consecutiveChecks >= 3) {
          consecutiveChecks = 0;
        }
        
        // Perform actual connection test
        isCheckingConnection = true;
        const actuallyOnline = await checkRealConnection();
        isCheckingConnection = false;
        
        // If we're reconnecting but socket is now connected, mark as online
        if (currentConnectionState === 'reconnecting' && socketConnected && actuallyOnline) {
          setConnectionStatus('online', { reason: 'Connection restored', silent: true });
          return;
        }
        
        // If we're offline but connection is back, reconnect
        if (currentConnectionState === 'offline' && actuallyOnline) {
          if (!socketConnected) {
            socket.connect();
          } else {
            setConnectionStatus('online', { reason: 'Connection restored', silent: true });
          }
          return;
        }
        
        // If socket is disconnected, test actual connection
        if (!socketConnected || currentConnectionState === 'reconnecting') {
          if (!actuallyOnline && currentConnectionState !== 'offline') {
            setConnectionStatus('offline', { reason: 'Cannot reach server', silent: true });
          } else if (actuallyOnline && !socketConnected) {
            setConnectionStatus('reconnecting', { silent: true });
            socket.connect();
          }
        }
        
        // IMPORTANT: Also check when showing online (detect disconnection faster)
        if (currentConnectionState === 'online' && !actuallyOnline) {
          setConnectionStatus('offline', { reason: 'Connection lost', silent: true });
        }
      }, 1000); // Check every 1 second

      // Check connection when page becomes visible (mobile app switching)
      document.addEventListener('visibilitychange', async () => {
        if (!document.hidden) {
          // Test actual connection
          const actuallyOnline = await checkRealConnection();
          
          if (!actuallyOnline && currentConnectionState !== 'offline') {
            setConnectionStatus('offline', { reason: 'Cannot reach server', silent: true });
          } else if (actuallyOnline && currentConnectionState === 'offline') {
            if (!socket.connected) {
              socket.connect();
            } else {
              setConnectionStatus('online', { reason: 'Connection restored', silent: true });
            }
          } else if (actuallyOnline && !socket.connected) {
            setConnectionStatus('reconnecting', { silent: true });
            socket.connect();
          }
        }
      });

      // Check connection on any user interaction (for immediate feedback)
      let lastInteractionCheck = 0;
      const checkConnectionOnInteraction = async () => {
        const now = Date.now();
        // Throttle to once per second
        if (now - lastInteractionCheck < 1000) return;
        lastInteractionCheck = now;
        
        // Always do actual connection test
        const actuallyOnline = await checkRealConnection();
        
        // If we're offline but connection is back, reconnect
        if (currentConnectionState === 'offline' && actuallyOnline) {
          if (!socket.connected) {
            socket.connect();
          } else {
            setConnectionStatus('online', { reason: 'Connection restored', silent: true });
          }
          return;
        }
        
        // First check navigator.onLine
        if (!navigator.onLine && currentConnectionState !== 'offline') {
          setConnectionStatus('offline', { reason: 'Network unavailable', silent: true });
          return;
        }
        
        if (!actuallyOnline && currentConnectionState !== 'offline') {
          setConnectionStatus('offline', { reason: 'Cannot reach server', silent: true });
        } else if (actuallyOnline && !socket.connected && currentConnectionState !== 'reconnecting') {
          setConnectionStatus('reconnecting', { silent: true });
        }
      };

      // Add interaction listeners
      document.addEventListener('click', checkConnectionOnInteraction);
      document.addEventListener('touchstart', checkConnectionOnInteraction);
      textarea.addEventListener('focus', checkConnectionOnInteraction);

      // Get current environment from URL
      const currentPath = window.location.pathname;
      const environmentName = currentPath === '/' ? 'default' : currentPath.slice(1);
      const environmentPath = currentPath === '/' ? '' : currentPath;
      
      // Initialize Local Version Control for this environment
      const localVersionControl = new LocalVersionControl(environmentName);
      
      // Application state
      let connectedUsers = 1;
      let activeUploads = new Set();
      let canceledUploads = new Set(); // Track which uploads have been canceled
  // Track if image preview modal is currently open to prevent accidental re-uploads
  let imagePreviewOpen = false;
      
      // Custom Confirmation Dialog System
      function showConfirm(message, title = 'Confirm Action', type = 'warning') {
        return new Promise((resolve) => {
          const overlay = document.getElementById('confirm-overlay');
          const dialog = document.querySelector('.confirm-dialog');
          const titleEl = document.getElementById('confirm-title');
          const messageEl = document.getElementById('confirm-message');
          const iconEl = document.getElementById('confirm-icon');
          const okBtn = document.getElementById('confirm-ok');
          const cancelBtn = document.getElementById('confirm-cancel');
          
          // Set content
          titleEl.textContent = title;
          messageEl.textContent = message;
          
          // Set icon and styling based on type
          iconEl.className = `confirm-icon ${type}`;
          switch(type) {
            case 'danger':
              iconEl.innerHTML = '<i class="fas fa-exclamation-triangle"></i>';
              okBtn.className = 'confirm-btn danger';
              okBtn.textContent = 'Delete';
              break;
            case 'warning':
              iconEl.innerHTML = '<i class="fas fa-exclamation-triangle"></i>';
              okBtn.className = 'confirm-btn primary';
              okBtn.textContent = 'Confirm';
              break;
            case 'info':
              iconEl.innerHTML = '<i class="fas fa-info-circle"></i>';
              okBtn.className = 'confirm-btn primary';
              okBtn.textContent = 'OK';
              break;
            default:
              iconEl.innerHTML = '<i class="fas fa-question-circle"></i>';
              okBtn.className = 'confirm-btn primary';
              okBtn.textContent = 'Confirm';
          }
          
          // Show dialog with animation
          overlay.style.display = 'flex';
          requestAnimationFrame(() => {
            overlay.classList.add('show');
          });
          
          // Handle responses
          const handleResponse = (result) => {
            overlay.classList.remove('show');
            setTimeout(() => {
              overlay.style.display = 'none';
            }, 300);
            resolve(result);
          };
          
          // Event listeners
          okBtn.onclick = () => handleResponse(true);
          cancelBtn.onclick = () => handleResponse(false);
          
          // Close on overlay click
          overlay.onclick = (e) => {
            if (e.target === overlay) {
              handleResponse(false);
            }
          };
          
          // Keyboard support
          const handleKeydown = (e) => {
            if (e.key === 'Escape') {
              handleResponse(false);
              document.removeEventListener('keydown', handleKeydown);
            } else if (e.key === 'Enter') {
              handleResponse(true);
              document.removeEventListener('keydown', handleKeydown);
            }
          };
          
          document.addEventListener('keydown', handleKeydown);
          
          // Focus the OK button
          setTimeout(() => okBtn.focus(), 100);
        });
      }
      
      // Environment Switcher Functions
      function showEnvironmentSwitcher() {
        const overlay = document.getElementById('env-switcher-overlay');
        const input = document.getElementById('env-name-input');
        const currentEnvName = document.getElementById('current-env-name');
        const switchBtn = document.getElementById('env-switch-btn');
        const cancelBtn = document.getElementById('env-cancel-btn');
        
        // Set current environment name
        currentEnvName.textContent = environmentName;
        
        // Clear input
        input.value = '';
        
        // Show dialog with animation
        overlay.style.display = 'flex';
        requestAnimationFrame(() => {
          overlay.classList.add('show');
          setTimeout(() => input.focus(), 100);
        });
        
        // Handle switch
        const handleSwitch = () => {
          const newEnv = input.value.trim();
          const targetEnv = newEnv === '' ? 'default' : newEnv;
          
          // Navigate to new environment
          const newPath = targetEnv === 'default' ? '/' : `/${encodeURIComponent(targetEnv)}`;
          window.location.href = newPath;
        };
        
        // Handle cancel
        const handleCancel = () => {
          overlay.classList.remove('show');
          setTimeout(() => {
            overlay.style.display = 'none';
          }, 300);
        };
        
        // Event listeners
        switchBtn.onclick = handleSwitch;
        cancelBtn.onclick = handleCancel;
        
        // Close on overlay click
        overlay.onclick = (e) => {
          if (e.target === overlay) {
            handleCancel();
          }
        };
        
        // Keyboard support
        const handleKeydown = (e) => {
          if (e.key === 'Escape') {
            handleCancel();
            document.removeEventListener('keydown', handleKeydown);
          } else if (e.key === 'Enter') {
            handleSwitch();
            document.removeEventListener('keydown', handleKeydown);
          }
        };
        
        document.addEventListener('keydown', handleKeydown);
      }
      
      // Initialize application
      function initializeApp() {
        // Join the appropriate environment room
        socket.emit('joinEnvironment', environmentName);
        
        // Setup file icons
        updateFileIcons();
        
        // Setup text previews
        setupTextPreviews();
        
        // Setup PDF previews
        setupPDFPreviews();
        
        // Setup video previews
        setupVideoPreviews();
        
        // VNC performance check
        if (isVNCConnection()) {
          document.body.classList.add('no-animate');
          console.log('VNC connection detected - animations disabled for better performance');
        }
        
        // Add global click handlers to close modals when clicking outside
        document.addEventListener('click', function(e) {
          const imageModal = document.getElementById('image-modal');
          const textModal = document.getElementById('text-modal');
          const pdfModal = document.getElementById('pdf-modal');
          const videoModal = document.getElementById('video-modal');
          const versionModal = document.getElementById('version-modal');
          
          if (e.target === imageModal) {
            closeImageModal();
          }
          if (e.target === textModal) {
            closeTextModal();
          }
          if (e.target === pdfModal) {
            closePDFModal();
          }
          if (e.target === videoModal) {
            closeVideoModal();
          }
          if (e.target === versionModal) {
            closeVersionModal();
          }
        });
        
        // Add escape key to close modals
        document.addEventListener('keydown', function(e) {
          if (e.key === 'Escape') {
            const imageModal = document.getElementById('image-modal');
            const textModal = document.getElementById('text-modal');
            const pdfModal = document.getElementById('pdf-modal');
            const versionModal = document.getElementById('version-modal');
            
            if (imageModal.classList.contains('show')) {
              closeImageModal();
            } else if (textModal.classList.contains('show')) {
              closeTextModal();
            } else if (pdfModal.classList.contains('show')) {
              closePDFModal();
            } else if (videoModal.classList.contains('show')) {
              closeVideoModal();
            } else if (versionModal.classList.contains('show')) {
              closeVersionModal();
            }
          }
        });
        
        console.log('%cðŸš€ RealTime Clipboard 2.0!', 
          'color: #2563eb; font-size: 16px; font-weight: bold;');
      }

      // Detect VNC connection (heuristic)
      function isVNCConnection() {
        // Check for common VNC indicators
        const userAgent = navigator.userAgent.toLowerCase();
        const isLowBandwidth = navigator.connection && navigator.connection.downlink < 1;
        const isRemoteDesktop = userAgent.includes('rdp') || userAgent.includes('vnc') || 
                               userAgent.includes('remote') || window.screen.colorDepth < 24;
        
        return isLowBandwidth || isRemoteDesktop;
      }

      // Enhanced file icon detection
      function getFileIcon(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        const iconMap = {
          // Documents
          'pdf': 'fas fa-file-pdf',
          'doc': 'fas fa-file-word', 'docx': 'fas fa-file-word',
          'xls': 'fas fa-file-excel', 'xlsx': 'fas fa-file-excel',
          'ppt': 'fas fa-file-powerpoint', 'pptx': 'fas fa-file-powerpoint',
          'txt': 'fas fa-file-alt', 'md': 'fas fa-file-alt',
          
          // Images
          'jpg': 'fas fa-file-image', 'jpeg': 'fas fa-file-image',
          'png': 'fas fa-file-image', 'gif': 'fas fa-file-image',
          'svg': 'fas fa-file-image', 'webp': 'fas fa-file-image',
          
          // Code
          'js': 'fas fa-file-code', 'ts': 'fas fa-file-code',
          'html': 'fas fa-file-code', 'css': 'fas fa-file-code',
          'json': 'fas fa-file-code', 'xml': 'fas fa-file-code',
          'py': 'fas fa-file-code', 'java': 'fas fa-file-code',
          'cpp': 'fas fa-file-code', 'c': 'fas fa-file-code',
          
          // Archives
          'zip': 'fas fa-file-archive', 'rar': 'fas fa-file-archive',
          '7z': 'fas fa-file-archive', 'tar': 'fas fa-file-archive',
          'gz': 'fas fa-file-archive',
          
          // Media
          'mp3': 'fas fa-file-audio', 'wav': 'fas fa-file-audio',
          'mp4': 'fas fa-file-video', 'avi': 'fas fa-file-video',
          'mov': 'fas fa-file-video', 'wmv': 'fas fa-file-video'
        };
        
        return iconMap[ext] || 'fas fa-file';
      }

      // Update file icons and setup image thumbnails
      function updateFileIcons() {
        document.querySelectorAll('[data-filename]').forEach(item => {
          const filename = item.getAttribute('data-filename');
          
          // Skip files that have preview icons (image, text, or PDF)
          if (item.querySelector('.image-thumbnail') || 
              item.querySelector('.text-preview-icon') || 
              item.querySelector('.pdf-preview-icon')) {
            return; // These files already have their preview elements
          }
          
          const icon = item.querySelector('.file-icon i');
          
          // Check if this is an image file
          const isImage = isImageFile(filename);
          
          if (icon) {
            icon.className = getFileIcon(filename, isImage);
            if (isImage) {
              icon.parentElement.classList.add('image-icon');
            }
          }
        });
        
        // Setup hover functionality for image thumbnails
        setupImageThumbnails();
        setupTextPreviews();
        setupPDFPreviews();
      }
      
      // Helper function to check if a file is an image
      function isImageFile(filename) {
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg', '.bmp', '.ico', '.tiff', '.tif'];
        const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
        return imageExtensions.includes(ext);
      }
      
      // Helper function to check if a file is a PDF
      function isPDFFile(filename) {
        const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
        return ext === '.pdf';
      }
      
      // Simple modal functions for image preview
      function showImageModal(imageUrl, filename) {
        console.log('Opening modal for:', imageUrl, filename);
        const modal = document.getElementById('image-modal');
        const modalImage = document.getElementById('modal-image');
        const modalFilename = document.getElementById('modal-filename');
        imagePreviewOpen = true; // mark preview as open
        
        modalImage.src = imageUrl;
        modalImage.alt = filename;
        modalFilename.textContent = filename;
        
        modal.classList.add('show');
        document.body.style.overflow = 'hidden'; // Prevent background scrolling
      }
      
      function closeImageModal() {
        const modal = document.getElementById('image-modal');
        modal.classList.remove('show');
        document.body.style.overflow = ''; // Restore scrolling
        imagePreviewOpen = false; // mark preview as closed
      }
      
      // Setup click functionality for image thumbnails
      function setupImageThumbnails() {
        document.querySelectorAll('.image-thumbnail').forEach(thumbnail => {
          // Remove existing event listeners to prevent duplicates
          const newThumbnail = thumbnail.cloneNode(true);
          thumbnail.parentNode.replaceChild(newThumbnail, thumbnail);
          
          console.log('Setting up thumbnail click for:', newThumbnail);
          
          // Add click functionality
          newThumbnail.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const imageUrl = this.getAttribute('data-image-url');
            const filename = this.getAttribute('data-filename');
            
            console.log('Thumbnail clicked:', imageUrl, filename);
            
            if (imageUrl && filename) {
              showImageModal(imageUrl, filename);
            }
          });
        });
      }

      // Text preview functions
      async function showTextModal(previewUrl, filename) {
        console.log('Opening text preview for:', previewUrl, filename);
        
        const modal = document.getElementById('text-modal');
        const modalFilename = document.getElementById('text-modal-filename');
        const modalInfo = document.getElementById('text-modal-info');
        const modalContent = document.getElementById('text-modal-content');
        
        // Show modal and loading state
        modalFilename.textContent = filename;
        modalInfo.textContent = 'Loading...';
        modalContent.textContent = 'Loading file content...';
        modal.classList.add('show');
        document.body.style.overflow = 'hidden';
        
        try {
          const response = await fetch(previewUrl);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          
          const data = await response.json();
          
          // Update modal content
          modalInfo.textContent = `${data.extension.toUpperCase()} â€¢ ${formatFileSize(data.size)}`;
          modalContent.textContent = data.content;
          
          // Add language class for basic syntax highlighting
          modalContent.className = 'text-content';
          const ext = data.extension.toLowerCase();
          if (['.js', '.jsx'].includes(ext)) {
            modalContent.classList.add('language-js');
          } else if (['.html', '.htm'].includes(ext)) {
            modalContent.classList.add('language-html');
          } else if (ext === '.css') {
            modalContent.classList.add('language-css');
          } else if (ext === '.json') {
            modalContent.classList.add('language-json');
          }
          
        } catch (error) {
          console.error('Error loading text preview:', error);
          modalInfo.textContent = 'Error loading file';
          modalContent.textContent = `Failed to load file content: ${error.message}`;
        }
      }
      
      function closeTextModal() {
        const modal = document.getElementById('text-modal');
        modal.classList.remove('show');
        document.body.style.overflow = '';
      }

      // PDF Modal Functions
      function showPDFModal(pdfUrl, filename) {
        console.log('Opening PDF preview for:', pdfUrl, filename);
        
        const modal = document.getElementById('pdf-modal');
        const modalFilename = document.getElementById('pdf-modal-filename');
        const modalInfo = document.getElementById('pdf-modal-info');
        const modalIframe = document.getElementById('pdf-modal-iframe');
        
        // Show modal and loading state
        modalFilename.textContent = filename;
        modalInfo.textContent = 'Loading PDF...';
        modalIframe.src = '';
        modal.classList.add('show');
        document.body.style.overflow = 'hidden';
        
        // Load PDF in iframe
        modalIframe.src = pdfUrl;
        modalInfo.textContent = `PDF Document`;
        
        // Handle iframe load events
        modalIframe.onload = function() {
          modalInfo.textContent = `PDF Document â€¢ Ready`;
        };
        
        modalIframe.onerror = function() {
          modalInfo.textContent = `Error loading PDF`;
        };
      }
      
      function closePDFModal() {
        const modal = document.getElementById('pdf-modal');
        const modalIframe = document.getElementById('pdf-modal-iframe');
        modal.classList.remove('show');
        modalIframe.src = ''; // Stop loading PDF
        document.body.style.overflow = '';
      }

      function setupPDFPreviews() {
        document.querySelectorAll('.pdf-preview-icon').forEach(preview => {
          // Remove existing event listeners to prevent duplicates
          const newPreview = preview.cloneNode(true);
          preview.parentNode.replaceChild(newPreview, preview);
          
          console.log('Setting up PDF preview click for:', newPreview);
          
          // Add click functionality
          newPreview.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const pdfUrl = this.getAttribute('data-pdf-url');
            const filename = this.getAttribute('data-filename');
            
            console.log('PDF preview clicked:', pdfUrl, filename);
            
            if (pdfUrl && filename) {
              showPDFModal(pdfUrl, filename);
            }
          });
        });
      }

      // Video Modal Functions
      function showVideoModal(videoUrl, filename) {
        console.log('Opening video preview for:', videoUrl, filename);
        
        const modal = document.getElementById('video-modal');
        const modalFilename = document.getElementById('video-modal-filename');
        const modalInfo = document.getElementById('video-modal-info');
        const modalPlayer = document.getElementById('video-modal-player');
        
        // Show modal and loading state
        modalFilename.textContent = filename;
        modalInfo.textContent = 'Loading video...';
        modalPlayer.src = '';
        modal.classList.add('show');
        document.body.style.overflow = 'hidden';
        
        // Load video
        modalPlayer.src = videoUrl;
        modalInfo.textContent = `Video â€¢ Ready`;
        
        // Handle video load events
        modalPlayer.onloadedmetadata = function() {
          const duration = Math.floor(modalPlayer.duration);
          const minutes = Math.floor(duration / 60);
          const seconds = duration % 60;
          modalInfo.textContent = `Video â€¢ ${minutes}:${seconds.toString().padStart(2, '0')}`;
        };
        
        modalPlayer.onerror = function() {
          modalInfo.textContent = `Error loading video`;
        };
      }
      
      function closeVideoModal() {
        const modal = document.getElementById('video-modal');
        const modalPlayer = document.getElementById('video-modal-player');
        modal.classList.remove('show');
        modalPlayer.pause(); // Pause video playback
        modalPlayer.src = ''; // Stop loading video
        document.body.style.overflow = '';
      }

      function setupVideoPreviews() {
        document.querySelectorAll('.video-preview-icon').forEach(preview => {
          // Remove existing event listeners to prevent duplicates
          const newPreview = preview.cloneNode(true);
          preview.parentNode.replaceChild(newPreview, preview);
          
          console.log('Setting up video preview click for:', newPreview);
          
          // Add click functionality
          newPreview.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const videoUrl = this.getAttribute('data-video-url');
            const filename = this.getAttribute('data-filename');
            
            console.log('Video preview clicked:', videoUrl, filename);
            
            if (videoUrl && filename) {
              showVideoModal(videoUrl, filename);
            }
          });
        });
      }
      
      // Setup click functionality for text preview icons
      function setupTextPreviews() {
        document.querySelectorAll('.text-preview-icon').forEach(preview => {
          // Remove existing event listeners to prevent duplicates
          const newPreview = preview.cloneNode(true);
          preview.parentNode.replaceChild(newPreview, preview);
          
          console.log('Setting up text preview click for:', newPreview);
          
          // Add click functionality
          newPreview.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const previewUrl = this.getAttribute('data-preview-url');
            const filename = this.getAttribute('data-filename');
            
            console.log('Text preview clicked:', previewUrl, filename);
            
            if (previewUrl && filename) {
              showTextModal(previewUrl, filename);
            }
          });
        });
      }

      // Clear clipboard function
      async function clearClipboard() {
        if (textarea.value.trim()) {
          const confirmed = await showConfirm(
            'This will permanently clear all clipboard content.\n\nThis action cannot be undone.',
            'Clear Clipboard',
            'warning'
          );
          
          if (confirmed) {
            textarea.value = '';
            socket.emit("textChange", '');
            showNotification('Clipboard cleared successfully', 'success');
          }
        }
      }

      // Simple notification system (VNC friendly - no complex animations)
      function showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 80px;
          right: 20px;
          z-index: 1001;
          background: var(--card-bg);
          border: 2px solid var(--primary-blue);
          color: var(--text-primary);
          padding: 12px 16px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 500;
          max-width: 300px;
          box-shadow: var(--shadow-medium);
        `;
        
        const colors = {
          success: 'var(--success-green)',
          error: 'var(--danger-blue)',
          warning: 'var(--warning-yellow)',
          info: 'var(--primary-blue)'
        };
        
        notification.style.borderColor = colors[type] || colors.info;
        notification.textContent = message;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 3000);
      }

      // Update file counts
      function updateFileCounts() {
        const count = document.querySelectorAll('.file-item[data-filename]').length;
        if (fileCount) fileCount.textContent = count;
        if (filesCount) filesCount.textContent = count;
      }
      
      // Handle page unload/close - cancel active uploads
      window.addEventListener('beforeunload', function(event) {
        if (activeUploads.size > 0) {
          // Cancel all active uploads
          activeUploads.forEach(uploadId => {
            canceledUploads.add(uploadId); // Mark as canceled
            // Use sendBeacon for reliable delivery during page unload
            navigator.sendBeacon(`/upload/cancel/${uploadId}`);
          });
          
          // Optional: Show a warning if user tries to leave during upload
          event.preventDefault();
          event.returnValue = 'Upload in progress. Are you sure you want to leave?';
          return event.returnValue;
        }
      });
      
      // Handle visibility change (tab switch, minimize)
      document.addEventListener('visibilitychange', function() {
        if (document.hidden && activeUploads.size > 0) {
          console.log('Page hidden with active uploads, monitoring for cleanup...');
          
          // Start a timer to cancel uploads if page stays hidden too long
          setTimeout(() => {
            if (document.hidden && activeUploads.size > 0) {
              console.log('Page still hidden after 5 minutes, canceling uploads...');
              activeUploads.forEach(uploadId => {
                canceledUploads.add(uploadId); // Mark as canceled
                fetch(`/upload/cancel/${uploadId}`, { method: 'DELETE' })
                  .catch(err => console.log('Failed to cancel upload:', err));
              });
            }
          }, 5 * 60 * 1000); // 5 minutes
        }
      });

      // Socket event handlers
      socket.on("textUpdate", (text) => {
        if (textarea.value !== text) {
          textarea.value = text;
          // Subtle visual feedback without complex animations
          textarea.style.borderLeft = '3px solid var(--primary-blue)';
          setTimeout(() => {
            textarea.style.borderLeft = '';
          }, 1000);
        }
        // Initialize local version control with current text if not already initialized
        if (localVersionControl.versions.length === 0) {
          localVersionControl.initialize(text);
        }
      });

      socket.on("userConnected", (data) => {
        connectedUsers = data.userCount || connectedUsers + 1;
        if (usersCount) usersCount.textContent = connectedUsers;
        showNotification(`ðŸ‘‹ User joined (${connectedUsers} total)`, 'info');
      });

      socket.on("userDisconnected", (data) => {
        connectedUsers = data.userCount || Math.max(1, connectedUsers - 1);
        if (usersCount) usersCount.textContent = connectedUsers;
        showNotification(`ðŸ‘‹ User left (${connectedUsers} total)`, 'info');
      });

      // Real-time input handling - no debounce for instant synchronization
      textarea.addEventListener("input", () => {
        socket.emit("textChange", textarea.value);
        // Schedule auto-save to local storage (debounced)
        localVersionControl.scheduleAutoSave(textarea.value);
      });

      socket.on("fileUpdate", () => {
        updateFileList();
      });

      function updateFileList() {
        // Use the new API to get detailed file information including versions
        fetch(`${environmentPath}/files?json=true&versions=true`)
          .then((response) => response.json())
          .then((files) => {
            renderFileList(files);
            attachDeleteEventListeners();
            updateFileIcons();
            setupImageThumbnails();
            setupTextPreviews();
            setupPDFPreviews();
            setupVideoPreviews();
            updateFileCounts();
          })
          .catch((error) => {
            console.error('Error updating file list:', error);
            showNotification('Failed to update file list', 'error');
            
            // Fallback to HTML method
            fetch(window.location.pathname)
              .then((response) => response.text())
              .then((html) => {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, "text/html");
                const newFileList = doc.getElementById("file-list");
                if (newFileList) {
                  fileList.innerHTML = newFileList.innerHTML;
                  attachDeleteEventListeners();
                  updateFileIcons();
                  setupImageThumbnails();
                  setupTextPreviews();
                  setupPDFPreviews();
                  setupVideoPreviews();
                  updateFileCounts();
                }
              })
              .catch(() => {
                showNotification('Failed to update file list', 'error');
              });
          });
      }
      
      function renderFileList(files) {
        if (files.length === 0) {
          fileList.innerHTML = `
            <div style="text-align: center; padding: 40px 20px; color: var(--text-muted);">
              <i class="fas fa-folder-open" style="font-size: 48px; margin-bottom: 15px; display: block; opacity: 0.5;"></i>
              <p>No files uploaded yet</p>
              <p style="font-size: 12px; margin-top: 8px;">ðŸ’¡ Paste images directly with Ctrl+V</p>
            </div>
          `;
          return;
        }
        
        // Sort files by upload date (most recent first).
        // Prefer currentVersion.uploadedAt, fallback to file.lastModified, otherwise epoch.
        const sortedFiles = [...files].sort((a, b) => {
          const getDate = (f) => {
            if (f && f.currentVersion && f.currentVersion.uploadedAt) {
              const d = new Date(f.currentVersion.uploadedAt);
              if (!isNaN(d)) return d;
            }
            if (f && f.lastModified) {
              const d2 = new Date(f.lastModified);
              if (!isNaN(d2)) return d2;
            }
            return new Date(0);
          };

          return getDate(b) - getDate(a); // newest first
        });

        const fileItems = sortedFiles.map(file => {
          const fileName = file.originalFileName;
          const isImage = file.isImageFile;
          const isText = file.isTextFile;
          // Check isPDFFile property first, then fall back to file extension check for older files
          const isPDF = file.isPDFFile || (fileName && fileName.toLowerCase().endsWith('.pdf'));
          // Check isVideoFile property
          const isVideo = file.isVideoFile;
          const totalVersions = file.totalVersions;
          const hasMultipleVersions = totalVersions > 1;

          // Determine display upload date (prefer currentVersion.uploadedAt, fallback to lastModified)
          let displayDateRaw = null;
          if (file && file.currentVersion && file.currentVersion.uploadedAt) {
            displayDateRaw = file.currentVersion.uploadedAt;
          } else if (file && file.lastModified) {
            displayDateRaw = file.lastModified;
          }
          // Restore previous compact local date + hour:minute format
          let uploadDate = 'Unknown';
          if (displayDateRaw) {
            const d = new Date(displayDateRaw);
            uploadDate = d.toLocaleDateString() + ' ' + d.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
          }

          // Determine file size (prefer currentVersion.fileSize, fallback to size)
          const sizeBytes = (file && file.currentVersion && typeof file.currentVersion.fileSize === 'number')
            ? file.currentVersion.fileSize
            : (file && typeof file.size === 'number' ? file.size : 0);
          const fileSize = sizeBytes ? formatFileSize(sizeBytes) : '';
          
          return `
            <div class="file-item ${isImage ? 'has-image' : ''} ${isText ? 'has-text' : ''} ${isPDF ? 'has-pdf' : ''} ${isVideo ? 'has-video' : ''} ${hasMultipleVersions ? 'has-versions' : ''}" 
                 data-filename="${fileName}" 
                 data-versions="${totalVersions}">
              <div class="file-info">
                ${isImage ? `
                  <div class="image-thumbnail" 
                       data-image-url="${environmentPath}/files/${fileName}"
                       data-filename="${fileName}">
                    <img src="${environmentPath}/files/${fileName}" 
                         alt="${fileName}" 
                         class="thumbnail-img"
                         loading="lazy" />
                    <div class="image-overlay">
                      <i class="fas fa-search-plus"></i>
                    </div>
                  </div>
                ` : isText ? `
                  <div class="text-preview-icon" 
                       data-preview-url="${environmentPath}/files/${fileName}/preview"
                       data-filename="${fileName}">
                    <div class="text-icon">
                      <i class="fas fa-file-alt"></i>
                    </div>
                    <div class="text-overlay">
                      <i class="fas fa-eye"></i>
                    </div>
                  </div>
                ` : isPDF ? `
                  <div class="pdf-preview-icon" 
                       data-pdf-url="${environmentPath}/files/${fileName}/pdf-preview"
                       data-filename="${fileName}">
                    <div class="pdf-icon-text">PDF</div>
                    <div class="pdf-overlay">
                      <i class="fas fa-eye"></i>
                    </div>
                  </div>
                ` : isVideo ? `
                  <div class="video-preview-icon" 
                       data-video-url="${environmentPath}/files/${fileName}"
                       data-filename="${fileName}">
                    <div class="video-icon-text">â–¶</div>
                    <div class="video-overlay">
                      <i class="fas fa-play"></i>
                    </div>
                  </div>
                ` : `
                  <div class="file-icon">
                    <i class="fas fa-file" id="file-icon-${fileName.replace(/[^a-zA-Z0-9]/g, '')}"></i>
                  </div>
                `}
                <div class="file-details">
                  <a href="${environmentPath}/files/${fileName}"
                     download
                     class="file-name"
                     title="${fileName}">
                    ${fileName}
                  </a>
                  <div class="file-metadata">
                    <span class="file-date" title="${uploadDate}">
                      <i class="fas fa-clock"></i>
                      ${uploadDate}
                    </span>
                    ${fileSize ? `<span class="file-size">${fileSize}</span>` : ''}
                  </div>
                  ${hasMultipleVersions ? `
                    <div class="version-info">
                      <i class="fas fa-history"></i>
                      <span class="version-count">${totalVersions} versions</span>
                      <button class="btn-versions" onclick="showVersions('${fileName}')" title="View all versions">
                        <i class="fas fa-chevron-down"></i>
                      </button>
                    </div>
                  ` : ''}
                </div>
              </div>
              <div class="file-actions">
                ${hasMultipleVersions ? `
                  <button type="button"
                          class="versions-button btn btn-secondary"
                          style="padding: 8px 12px; font-size: 12px; margin-right: 8px;"
                          title="Manage versions"
                          onclick="showVersions('${fileName}')">
                    <i class="fas fa-history"></i>
                  </button>
                ` : ''}
                <button type="button"
                        class="delete-button btn btn-danger"
                        style="padding: 8px 12px; font-size: 12px;"
                        title="Delete file">
                  <i class="fas fa-trash"></i>
                </button>
              </div>
            </div>
          `;
        }).join('');
        
        fileList.innerHTML = fileItems;
      }

      // Prevent accidental form submission (no submit button now)
      uploadForm.addEventListener("submit", (event) => {
        event.preventDefault();
      });

      // Auto-upload on file selection
      fileInput.addEventListener('change', function(e) {
        const files = e.target.files;
        if (files.length > 0) {
          const fileNames = Array.from(files).map(f => f.name);
          const displayNames = fileNames.length > 3 
            ? fileNames.slice(0, 3).join(', ') + ` and ${fileNames.length - 3} more`
            : fileNames.join(', ');
          showNotification(`ðŸ“ Uploading: ${displayNames}`, 'info');
          
          // Automatically upload selected files
          uploadFiles(files);
          fileInput.value = ''; // Clear input after upload
        }
      });

      // Enhanced drag and drop with better visual feedback
      let dragCounter = 0;

      document.addEventListener("dragenter", (event) => {
        event.preventDefault();
        // If the image preview is open, ignore drag events to avoid accidental duplicate uploads
        if (imagePreviewOpen) return;
        if (event.dataTransfer.items && event.dataTransfer.items[0].kind === "file") {
          dragCounter++;
          dropZone.style.display = "flex";
          
          // Add visual feedback to upload area
          const uploadArea = document.querySelector('.upload-area');
          if (uploadArea) {
            uploadArea.classList.add('dragover');
          }
        }
      });

      document.addEventListener("dragleave", (event) => {
        event.preventDefault();
        if (event.dataTransfer.items && event.dataTransfer.items[0].kind === "file") {
          dragCounter--;
          if (dragCounter === 0) {
            dropZone.style.display = "none";
            
            // Remove visual feedback
            const uploadArea = document.querySelector('.upload-area');
            if (uploadArea) {
              uploadArea.classList.remove('dragover');
            }
          }
        }
      });

      document.addEventListener("drop", (event) => {
        event.preventDefault();
        dropZone.style.display = "none";
        dragCounter = 0;
        const files = event.dataTransfer.files;
        // Prevent uploading while the image preview modal is open (user might be dragging the previewed image)
        if (imagePreviewOpen) {
          console.log('Drop ignored because image preview modal is open.');
          return; // Simply ignore to avoid creating new versions accidentally
        }
        
        // Remove visual feedback
        const uploadArea = document.querySelector('.upload-area');
        if (uploadArea) {
          uploadArea.classList.remove('dragover');
        }
        
        if (files.length > 0) {
          uploadFiles(files);
        }
      });

      window.addEventListener("dragleave", (event) => {
        if (event.clientX === 0 && event.clientY === 0) {
          dropZone.style.display = "none";
          dragCounter = 0;
        }
      });

      document.addEventListener("dragover", (event) => {
        event.preventDefault();
        if (imagePreviewOpen) {
          // Do not show drop zone while preview is open
          dropZone.style.display = 'none';
        }
      });

      textarea.addEventListener("dragover", (event) => {
        event.stopPropagation();
      });

      textarea.addEventListener("drop", (event) => {
        event.stopPropagation();
      });

      function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
      }
      
      function formatDate(dateString) {
        const date = new Date(dateString);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / (1000 * 60));
        const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
        
        if (diffMins < 1) {
          return 'Just now';
        } else if (diffMins < 60) {
          return `${diffMins} minute${diffMins !== 1 ? 's' : ''} ago`;
        } else if (diffHours < 24) {
          return `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
        } else if (diffDays < 7) {
          return `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;
        } else {
          return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        }
      }
      
      function formatDateFull(dateString) {
        const date = new Date(dateString);
        // Format: "September 26, 2025 at 2:09:22 PM"
        const options = {
          year: 'numeric',
          month: 'long', 
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          hour12: true
        };
        return date.toLocaleDateString('en-US', options);
      }
      
      function formatDateExact(dateString) {
        const date = new Date(dateString);
        // Format: "2025-09-26 14:09:22"
        return date.getFullYear() + '-' + 
               String(date.getMonth() + 1).padStart(2, '0') + '-' + 
               String(date.getDate()).padStart(2, '0') + ' ' +
               String(date.getHours()).padStart(2, '0') + ':' + 
               String(date.getMinutes()).padStart(2, '0') + ':' + 
               String(date.getSeconds()).padStart(2, '0');
      }
      
      // Version Management Functions
      async function showVersions(fileName) {
        try {
          const response = await fetch(`${environmentPath}/files/${fileName}/versions`);
          if (!response.ok) {
            throw new Error('Failed to load versions');
          }
          
          const versionData = await response.json();
          const modal = document.getElementById('version-modal');
          const title = document.getElementById('version-modal-title');
          const versionList = document.getElementById('version-list');
          
          title.innerHTML = `
            <i class="fas fa-history"></i>
            Versions of "${fileName}"
          `;
          
          const versionsHtml = versionData.versions.map(version => {
            const isCurrentVersion = version.versionId === versionData.currentVersion.versionId;
            return `
              <div class="version-item ${isCurrentVersion ? 'current' : ''}">
                <div class="version-details">
                  <div class="version-id">
                    ${version.versionId}
                    ${isCurrentVersion ? '<span class="current-badge">Current</span>' : ''}
                  </div>
                  <div class="version-date">
                    <i class="fas fa-calendar-alt"></i>
                    ${formatDateExact(version.uploadedAt)}
                  </div>
                  <div class="version-date-relative">${formatDate(version.uploadedAt)}</div>
                  <div class="version-size">
                    <i class="fas fa-file"></i>
                    ${formatFileSize(version.fileSize)}
                  </div>
                </div>
                <div class="version-actions">
                  <button class="version-btn" onclick="downloadVersion('${fileName}', '${version.versionId}')" title="Download this version">
                    <i class="fas fa-download"></i>
                    Download
                  </button>
                  ${!isCurrentVersion ? `
                    <button class="version-btn primary" onclick="promoteVersion('${fileName}', '${version.versionId}')" title="Make this the current version">
                      <i class="fas fa-arrow-up"></i>
                      Promote
                    </button>
                  ` : ''}
                  <button class="version-btn danger" onclick="deleteVersion('${fileName}', '${version.versionId}', ${isCurrentVersion})" title="Delete this version">
                    <i class="fas fa-trash"></i>
                    Delete
                  </button>
                </div>
              </div>
            `;
          }).join('');
          
          versionList.innerHTML = versionsHtml;
          modal.classList.add('show');
          document.body.style.overflow = 'hidden';
          
        } catch (error) {
          console.error('Error loading versions:', error);
          showNotification('Failed to load file versions', 'error');
        }
      }
      
      function closeVersionModal() {
        const modal = document.getElementById('version-modal');
        modal.classList.remove('show');
        document.body.style.overflow = '';
      }
      
      function downloadVersion(fileName, versionId) {
        const url = `${environmentPath}/files/${fileName}?version=${versionId}`;
        const link = document.createElement('a');
        link.href = url;
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
      
      async function promoteVersion(fileName, versionId) {
        const confirmed = await showConfirm(
          `Make this version of "${fileName}" the current version?\n\nThe current version will be moved to version history.`,
          'Promote Version',
          'info'
        );
        
        if (confirmed) {
          try {
            const response = await fetch(`${environmentPath}/files/${fileName}/versions/${versionId}/promote`, {
              method: 'PUT'
            });
            
            if (response.ok) {
              showNotification('Version promoted successfully', 'success');
              updateFileList();
              closeVersionModal();
              socket.emit('fileUpdate');
            } else {
              const error = await response.json();
              throw new Error(error.error || 'Failed to promote version');
            }
          } catch (error) {
            console.error('Error promoting version:', error);
            showNotification('Failed to promote version: ' + error.message, 'error');
          }
        }
      }
      
      async function deleteVersion(fileName, versionId, isCurrentVersion) {
        const message = isCurrentVersion 
          ? `Delete the current version of "${fileName}"?\n\nThe next most recent version will become the current version.`
          : `Delete this version of "${fileName}"?\n\nThis action cannot be undone.`;
          
        const confirmed = await showConfirm(message, 'Delete Version', 'danger');
        
        if (confirmed) {
          try {
            const response = await fetch(`${environmentPath}/files/${fileName}?version=${versionId}`, {
              method: 'DELETE'
            });
            
            if (response.ok) {
              const responseText = await response.text();
              if (responseText.includes('completely deleted')) {
                showNotification('File completely deleted (all versions removed)', 'success');
                closeVersionModal();
              } else {
                showNotification('Version deleted successfully', 'success');
                showVersions(fileName); // Refresh the version modal
              }
              updateFileList();
              socket.emit('fileUpdate');
            } else {
              throw new Error('Failed to delete version');
            }
          } catch (error) {
            console.error('Error deleting version:', error);
            showNotification('Failed to delete version: ' + error.message, 'error');
          }
        }
      }

      // Function to cancel all active uploads
      async function cancelAllUploads() {
        if (activeUploads.size === 0) {
          showNotification('No active uploads to cancel.', 'info');
          return;
        }
        
        const uploadCount = activeUploads.size;
        const confirmed = await showConfirm(
          `This will cancel ${uploadCount} active upload${uploadCount !== 1 ? 's' : ''}.\n\nFiles will be cleaned up automatically.`,
          'Cancel Uploads',
          'warning'
        );
        
        if (confirmed) {
          console.log(`Canceling ${uploadCount} active uploads...`);
          
          // Mark all active uploads as canceled BEFORE making server calls
          activeUploads.forEach((uploadId) => {
            canceledUploads.add(uploadId);
          });
          
          activeUploads.forEach(async (uploadId) => {
            try {
              await fetch(`${environmentPath}/upload/cancel/${uploadId}`, { method: 'DELETE' });
              console.log(`Canceled upload: ${uploadId}`);
            } catch (error) {
              console.error(`Failed to cancel upload ${uploadId}:`, error);
            }
          });
          
          activeUploads.clear();
          
          // Hide progress bars and show cancellation message
          progressContainer.style.display = "none";
          overallProgressBar.style.width = "0%";
          overallPercentage.textContent = "0%";
          chunkProgressBar.style.width = "0%";
          chunkPercentage.textContent = "0%";
          chunkProgressSection.style.display = "none";
          
          showNotification('Uploads canceled successfully. Files will be cleaned up shortly.', 'success');
        }
      }

      function uploadFiles(files) {
        // Check if any files are larger than 45MB (leaving buffer for Cloudflare's 50MB limit)
        const CHUNK_SIZE = 45 * 1024 * 1024; // 45MB chunks
        let hasLargeFiles = false;
        
        for (let file of files) {
          if (file.size > CHUNK_SIZE) {
            hasLargeFiles = true;
            break;
          }
        }
        
        if (hasLargeFiles) {
          uploadLargeFiles(files);
        } else {
          uploadSmallFiles(files);
        }
      }

      // Enhanced upload functions with better UX
      function uploadSmallFiles(files) {
        const formData = new FormData();
        let totalSize = 0;
        
        for (let i = 0; i < files.length; i++) {
          formData.append('files', files[i]);
          totalSize += files[i].size;
        }

        const xhr = new XMLHttpRequest();
        xhr.open("POST", `${environmentPath}/upload`, true);

        xhr.upload.onprogress = function (event) {
          if (event.lengthComputable) {
            const percentComplete = (event.loaded / event.total) * 100;
            overallProgressBar.style.width = percentComplete + "%";
            overallPercentage.textContent = Math.round(percentComplete) + "%";
          }
        };

        xhr.onloadstart = function () {
          progressContainer.style.display = "block";
          progressText.innerHTML = `
            <i class="fas fa-upload" style="margin-right: 8px;"></i>
            Uploading ${files.length} file${files.length !== 1 ? 's' : ''} (${formatFileSize(totalSize)})...
          `;
          chunkProgressSection.style.display = "none";
        };

        xhr.onload = function () {
          if (xhr.status === 200) {
            progressText.innerHTML = `
              <i class="fas fa-check-circle" style="margin-right: 8px; color: var(--success-green);"></i>
              Upload completed successfully!
            `;
            overallProgressBar.classList.add('success');
            showNotification('Files uploaded successfully!', 'success');
          } else {
            progressText.innerHTML = `
              <i class="fas fa-exclamation-circle" style="margin-right: 8px; color: var(--danger-red);"></i>
              Upload failed!
            `;
            showNotification('Upload failed! Please try again.', 'error');
          }
        };

        xhr.onerror = function () {
          progressText.innerHTML = `
            <i class="fas fa-exclamation-triangle" style="margin-right: 8px; color: var(--warning-yellow);"></i>
            Network error during upload!
          `;
          showNotification('Network error! Check your connection.', 'error');
        };

        xhr.onloadend = function () {
          setTimeout(() => {
            progressContainer.style.display = "none";
            overallProgressBar.style.width = "0%";
            overallPercentage.textContent = "0%";
            progressText.textContent = "";
            overallProgressBar.classList.remove('success');
          }, 2000);
          socket.emit("fileUpdate");
        };

        xhr.send(formData);
      }

      async function uploadLargeFiles(files) {
        const CHUNK_SIZE = 45 * 1024 * 1024; // 45MB chunks
        progressContainer.style.display = "block";
        chunkProgressSection.style.display = "block";
        
        try {
          let totalProgress = 0;
          const totalFiles = files.length;
          
          for (let i = 0; i < files.length; i++) {
            const file = files[i];
            const fileProgress = `File ${i + 1}/${totalFiles}: `;
            
            if (file.size > CHUNK_SIZE) {
              progressText.textContent = `${fileProgress}Uploading "${file.name}" (${formatFileSize(file.size)})`;
              await uploadFileInChunks(file, CHUNK_SIZE, i, totalFiles);
            } else {
              progressText.textContent = `${fileProgress}Uploading "${file.name}" (${formatFileSize(file.size)})`;
              chunkProgressSection.style.display = "none";
              await uploadSingleFile(file);
              
              // Update overall progress for small files
              totalProgress = ((i + 1) / totalFiles) * 100;
              overallProgressBar.style.width = totalProgress + "%";
              overallPercentage.textContent = Math.round(totalProgress) + "%";
            }
          }
          
          progressText.textContent = "âœ… All uploads completed successfully!";
          overallProgressBar.style.width = "100%";
          overallPercentage.textContent = "100%";
          chunkProgressSection.style.display = "none";
          
          setTimeout(() => {
            progressText.textContent = "";
          }, 2000);
        } catch (error) {
          console.error('Upload failed:', error);
          
          // Check if this is a cancellation error - if so, don't show ugly alert
          const isCancellationError = error.message && (
            error.message.includes('Upload was canceled by user') ||
            error.message.includes('Upload session not found') ||
            error.message.includes('canceled') ||
            (error.message.includes('Failed to upload chunk') && activeUploads.size === 0) // Chunk failure after cancellation
          );
          
          // Only show alert if this is NOT a cancellation-related error
          if (!isCancellationError) {
            progressText.textContent = "âŒ Upload failed!";
            chunkProgressSection.style.display = "none";
            
            // Cancel any active uploads on error
            activeUploads.forEach(uploadId => {
              fetch(`/upload/cancel/${uploadId}`, { method: 'DELETE' })
                .catch(err => console.log('Failed to cancel upload after error:', err));
            });
            activeUploads.clear();
            
            alert('Upload failed: ' + error.message);
            setTimeout(() => {
              progressText.textContent = "";
            }, 3000);
          } else {
            // This was a cancellation - just clean up silently
            console.log('Upload canceled by user, cleaning up silently...');
            progressText.textContent = "Upload canceled";
            chunkProgressSection.style.display = "none";
            setTimeout(() => {
              progressText.textContent = "";
            }, 1000);
          }
        } finally {
          setTimeout(() => {
            progressContainer.style.display = "none";
            overallProgressBar.style.width = "0%";
            overallPercentage.textContent = "0%";
            chunkProgressBar.style.width = "0%";
            chunkPercentage.textContent = "0%";
          }, 2000);
          socket.emit("fileUpdate");
        }
      }

      async function uploadSingleFile(file) {
        const formData = new FormData();
        formData.append('files', file);

        return new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          xhr.open("POST", `${environmentPath}/upload`, true);

          xhr.onload = function () {
            if (xhr.status === 200) {
              resolve();
            } else {
              reject(new Error(`Failed to upload ${file.name}`));
            }
          };

          xhr.onerror = function () {
            reject(new Error(`Network error uploading ${file.name}`));
          };

          xhr.send(formData);
        });
      }

      async function uploadFileInChunks(file, chunkSize, fileIndex, totalFiles) {
        const totalChunks = Math.ceil(file.size / chunkSize);
        
        // Initiate upload session
        const initResponse = await fetch(`${environmentPath}/upload/initiate`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            fileName: file.name,
            fileSize: file.size,
            totalChunks: totalChunks
          })
        });

        if (!initResponse.ok) {
          const errorText = await initResponse.text();
          console.error('Initiate upload error:', errorText);
          throw new Error(`Failed to initiate upload for ${file.name}: ${errorText}`);
        }

        const { uploadId } = await initResponse.json();
        
        // Track this upload for cleanup
        activeUploads.add(uploadId);
        
        // Upload chunks sequentially with progress tracking
        for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
          // Check if upload has been canceled before processing each chunk
          if (canceledUploads.has(uploadId)) {
            console.log(`Upload ${uploadId} was canceled, stopping chunk upload at ${chunkIndex}/${totalChunks}`);
            throw new Error('Upload was canceled by user');
          }
          
          const start = chunkIndex * chunkSize;
          const end = Math.min(start + chunkSize, file.size);
          const chunk = file.slice(start, end);
          
          // Update chunk progress info
          chunkLabel.textContent = `Chunk ${chunkIndex + 1} of ${totalChunks} (${formatFileSize(chunk.size)})`;
          chunkProgressBar.style.width = "0%";
          chunkPercentage.textContent = "0%";
          
          const formData = new FormData();
          formData.append('uploadId', uploadId);
          formData.append('chunkIndex', chunkIndex);
          formData.append('chunk', chunk);

          // Create XMLHttpRequest for progress tracking
          await new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            
            xhr.upload.onprogress = function(event) {
              if (event.lengthComputable) {
                const chunkProgress = (event.loaded / event.total) * 100;
                chunkProgressBar.style.width = chunkProgress + "%";
                chunkPercentage.textContent = Math.round(chunkProgress) + "%";
                
                // Calculate overall progress
                const completedChunks = chunkIndex;
                const currentChunkProgress = chunkProgress / 100;
                const fileProgress = (completedChunks + currentChunkProgress) / totalChunks;
                const totalProgress = ((fileIndex + fileProgress) / totalFiles) * 100;
                
                overallProgressBar.style.width = totalProgress + "%";
                overallPercentage.textContent = Math.round(totalProgress) + "%";
              }
            };
            
            xhr.onload = function() {
              if (xhr.status === 200) {
                // Chunk upload completed
                chunkProgressBar.style.width = "100%";
                chunkPercentage.textContent = "100%";
                resolve();
              } else {
                reject(new Error(`Failed to upload chunk ${chunkIndex + 1}/${totalChunks} for ${file.name}`));
              }
            };
            
            xhr.onerror = function() {
              reject(new Error(`Network error uploading chunk ${chunkIndex + 1}/${totalChunks} for ${file.name}`));
            };
            
            xhr.open('POST', `${environmentPath}/upload/chunk`);
            xhr.send(formData);
          });
          
          // Brief pause between chunks for better visual feedback
          await new Promise(resolve => setTimeout(resolve, 100));
        }

        // Complete upload
        progressText.textContent = progressText.textContent.replace(/Uploading/, 'Finalizing');
        chunkLabel.textContent = "Combining chunks...";
        chunkProgressBar.style.width = "100%";
        chunkPercentage.textContent = "100%";
        
        const completeResponse = await fetch(`${environmentPath}/upload/complete`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ uploadId })
        });

        if (!completeResponse.ok) {
          const errorText = await completeResponse.text();
          console.error('Complete upload error:', errorText);
          throw new Error(`Failed to complete upload for ${file.name}: ${errorText}`);
        }
        
        // Remove from active uploads when completed successfully
        activeUploads.delete(uploadId);
        canceledUploads.delete(uploadId); // Also clean up cancellation tracking
        
        // Force a file update to refresh the list
        socket.emit("fileUpdate");
      }

      // Enhanced delete event listeners with better UX
      // Handler function for delete button clicks
      async function handleDeleteClick(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const button = e.currentTarget;
        const fileItem = button.closest("[data-filename]");
        const filename = fileItem.getAttribute("data-filename");

        // Skip confirmation if Alt key is pressed
        const confirmed = e.altKey ? true : await showConfirm(
          `This will permanently delete "${filename}".\n\nThis action cannot be undone.`,
          'Delete File',
          'danger'
        );
        
        if (confirmed) {
          // Show loading state
          const originalHTML = button.innerHTML;
          button.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
          button.disabled = true;
          
          fetch(`${environmentPath}/files/${encodeURIComponent(filename)}`, {
            method: "DELETE",
          })
          .then((response) => {
            if (response.ok) {
              // Simple fade out for VNC compatibility
              fileItem.style.opacity = '0.3';
              setTimeout(() => {
                fileItem.remove();
                updateFileCounts();
              }, 300);
              
              socket.emit("fileUpdate");
              showNotification(`"${filename}" deleted successfully`, 'success');
            } else {
              button.innerHTML = originalHTML;
              button.disabled = false;
              showNotification(`Failed to delete "${filename}"`, 'error');
            }
          })
          .catch((error) => {
            console.error("Delete error:", error);
            button.innerHTML = originalHTML;
            button.disabled = false;
            showNotification(`Error deleting "${filename}"`, 'error');
          });
        }
      }

      function attachDeleteEventListeners() {
        const deleteButtons = document.querySelectorAll(".delete-button");
        deleteButtons.forEach((button) => {
          // Remove any existing listener first to prevent duplicates
          button.removeEventListener("click", handleDeleteClick);
          // Add the listener
          button.addEventListener("click", handleDeleteClick);
        });
      }

      // Enhanced resizer with better performance for VNC and touch support for mobile
      let isResizing = false;
      let previousLayoutWasMobile = isMobileLayout();
      
      // Helper function to check if we're on mobile
      function isMobileLayout() {
        return window.innerWidth <= 768;
      }
      
      // Function to reset sidebar styles when switching layouts
      function resetSidebarStyles() {
        const currentlyMobile = isMobileLayout();
        
        // Only reset if layout actually changed
        if (currentlyMobile !== previousLayoutWasMobile) {
          const contentArea = document.querySelector('.content-area');
          
          if (!currentlyMobile) {
            // Switching to desktop: remove mobile height styles
            sidebar.style.height = '';
            sidebar.style.maxHeight = '';
            sidebar.style.minHeight = '';
            
            if (contentArea) {
              contentArea.style.height = '';
              contentArea.style.maxHeight = '';
              contentArea.style.minHeight = '';
            }
          } else {
            // Switching to mobile: remove desktop width styles
            sidebar.style.width = '';
          }
          
          previousLayoutWasMobile = currentlyMobile;
        }
      }
      
      // Listen for window resize to handle layout changes
      let resizeTimeout;
      window.addEventListener('resize', function() {
        // Debounce the resize event
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(resetSidebarStyles, 100);
      });
      
      // Mouse events for desktop (horizontal resize)
      resizer.addEventListener("mousedown", function (e) {
        e.preventDefault();
        isResizing = true;
        
        if (isMobileLayout()) {
          // On mobile layout, use vertical resize with mouse
          document.addEventListener("mousemove", resizeMobileVertical);
          document.addEventListener("mouseup", stopResizeMobile);
          document.body.style.cursor = 'ns-resize';
        } else {
          // On desktop layout, use horizontal resize
          document.addEventListener("mousemove", resize);
          document.addEventListener("mouseup", stopResize);
          document.body.style.cursor = 'ew-resize';
        }
        
        document.body.style.userSelect = 'none';
      });

      // Touch events for mobile (vertical resize)
      resizer.addEventListener("touchstart", function (e) {
        e.preventDefault();
        isResizing = true;
        document.addEventListener("touchmove", resizeTouch, { passive: false });
        document.addEventListener("touchend", stopResizeTouch);
        document.body.style.userSelect = 'none';
      });

      // Desktop horizontal resize
      function resize(e) {
        if (!isResizing) return;
        
        const minWidth = 300;
        const maxWidth = Math.min(1200, window.innerWidth * 0.75);
        const newWidth = Math.max(minWidth, Math.min(maxWidth, e.clientX));
        sidebar.style.width = newWidth + "px";
      }
      
      // Mobile vertical resize with mouse
      function resizeMobileVertical(e) {
        if (!isResizing) return;
        
        const minHeight = window.innerHeight * 0.15;
        const maxHeight = window.innerHeight * 0.85;
        const mouseY = e.clientY;
        const newHeight = Math.max(minHeight, Math.min(maxHeight, window.innerHeight - mouseY));
        
        sidebar.style.height = newHeight + "px";
        sidebar.style.maxHeight = newHeight + "px";
        sidebar.style.minHeight = newHeight + "px";
        
        const contentArea = document.querySelector('.content-area');
        if (contentArea) {
          const contentHeight = window.innerHeight - newHeight;
          contentArea.style.height = contentHeight + "px";
          contentArea.style.maxHeight = contentHeight + "px";
          contentArea.style.minHeight = contentHeight + "px";
        }
      }

      function resizeTouch(e) {
        if (!isResizing) return;
        e.preventDefault();
        
        const touch = e.touches[0];
        const minHeight = window.innerHeight * 0.15; // Minimum 15% of viewport height
        const maxHeight = window.innerHeight * 0.85; // Maximum 85% of viewport height
        
        // Calculate height from the touch position
        // Since sidebar is at the bottom, we need to calculate from bottom to touch point
        const touchY = touch.clientY;
        const newHeight = Math.max(minHeight, Math.min(maxHeight, window.innerHeight - touchY));
        
        sidebar.style.height = newHeight + "px";
        sidebar.style.maxHeight = newHeight + "px";
        sidebar.style.minHeight = newHeight + "px";
        
        // Update content area height accordingly
        const contentArea = document.querySelector('.content-area');
        if (contentArea) {
          const contentHeight = window.innerHeight - newHeight;
          contentArea.style.height = contentHeight + "px";
          contentArea.style.maxHeight = contentHeight + "px";
          contentArea.style.minHeight = contentHeight + "px";
        }
      }

      function stopResize() {
        isResizing = false;
        document.removeEventListener("mousemove", resize);
        document.removeEventListener("mouseup", stopResize);
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
      }
      
      function stopResizeMobile() {
        isResizing = false;
        document.removeEventListener("mousemove", resizeMobileVertical);
        document.removeEventListener("mouseup", stopResizeMobile);
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
      }

      function stopResizeTouch() {
        isResizing = false;
        document.removeEventListener("touchmove", resizeTouch);
        document.removeEventListener("touchend", stopResizeTouch);
        document.body.style.userSelect = '';
      }

      // Clipboard paste functionality for images
      document.addEventListener('paste', async function(e) {
        const clipboardItems = e.clipboardData.items;
        if (imagePreviewOpen) {
          console.log('Image paste ignored because image preview modal is open.');
          return; // Avoid accidental duplication when user is inspecting an image
        }
        
        for (let i = 0; i < clipboardItems.length; i++) {
          const item = clipboardItems[i];
          
          // Check if the item is an image
          if (item.type.indexOf('image') !== -1) {
            e.preventDefault();
            
            const blob = item.getAsFile();
            if (blob) {
              // Check file size before processing (50MB limit)
              const maxSize = 50 * 1024 * 1024; // 50MB in bytes
              if (blob.size > maxSize) {
                showNotification('âŒ Image too large. Maximum size is 50MB.', 'error');
                return;
              }
              
              console.log('Processing pasted image:', {
                type: blob.type,
                size: blob.size,
                sizeFormatted: formatFileSize(blob.size)
              });
              
              // Convert blob to base64
              const reader = new FileReader();
              reader.onload = async function(event) {
                const base64Data = event.target.result;
                
                console.log('Base64 data length:', base64Data.length);
                
                try {
                  showNotification('ðŸ“‹ Uploading pasted image...', 'info');
                  
                  // Use root endpoint for better compatibility
                  const pasteUrl = environmentPath ? `${environmentPath}/paste-image` : '/paste-image';
                  
                  const response = await fetch(pasteUrl, {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                      imageData: base64Data
                    })
                  });
                  
                  if (response.ok) {
                    const result = await response.json();
                    showNotification(`âœ… Image pasted successfully as "${result.filename}"`, 'success');
                    socket.emit("fileUpdate");
                  } else {
                    // Handle both JSON and HTML error responses
                    let errorMessage = `HTTP ${response.status}`;
                    try {
                      const errorData = await response.json();
                      errorMessage = errorData.error || errorMessage;
                    } catch (jsonError) {
                      // If response is not JSON, try to get text
                      try {
                        const errorText = await response.text();
                        if (errorText.includes('413') || errorText.includes('Payload Too Large')) {
                          errorMessage = 'Image too large. Please try a smaller image.';
                        } else {
                          errorMessage = `Server error (${response.status})`;
                        }
                      } catch (textError) {
                        errorMessage = `Server error (${response.status})`;
                      }
                    }
                    console.error('Paste image error:', errorMessage);
                    showNotification(`âŒ Failed to paste image: ${errorMessage}`, 'error');
                  }
                  
                } catch (error) {
                  console.error('Error uploading pasted image:', error);
                  showNotification('âŒ Network error while uploading image', 'error');
                }
              };
              
              reader.readAsDataURL(blob);
            }
            break; // Only handle the first image
          }
        }
      });



      // Enhanced file icon detection to show thumbnails for images
      function getFileIcon(filename, isImage = false) {
        const ext = filename.split('.').pop().toLowerCase();
        
        if (isImage) {
          return 'fas fa-image'; // Use image icon for all images
        }
        
        const iconMap = {
          // Documents
          'pdf': 'fas fa-file-pdf',
          'doc': 'fas fa-file-word', 'docx': 'fas fa-file-word',
          'xls': 'fas fa-file-excel', 'xlsx': 'fas fa-file-excel',
          'ppt': 'fas fa-file-powerpoint', 'pptx': 'fas fa-file-powerpoint',
          'txt': 'fas fa-file-alt', 'md': 'fas fa-file-alt',
          
          // Code
          'js': 'fas fa-file-code', 'ts': 'fas fa-file-code',
          'html': 'fas fa-file-code', 'css': 'fas fa-file-code',
          'json': 'fas fa-file-code', 'xml': 'fas fa-file-code',
          'py': 'fas fa-file-code', 'java': 'fas fa-file-code',
          'cpp': 'fas fa-file-code', 'c': 'fas fa-file-code',
          
          // Archives
          'zip': 'fas fa-file-archive', 'rar': 'fas fa-file-archive',
          '7z': 'fas fa-file-archive', 'tar': 'fas fa-file-archive',
          'gz': 'fas fa-file-archive',
          
          // Media
          'mp3': 'fas fa-file-audio', 'wav': 'fas fa-file-audio',
          'mp4': 'fas fa-file-video', 'avi': 'fas fa-file-video',
          'mov': 'fas fa-file-video', 'wmv': 'fas fa-file-video'
        };
        
        return iconMap[ext] || 'fas fa-file';
      }

      // Keyboard shortcuts
      document.addEventListener('keydown', function(e) {
        // Ctrl+Alt+Z for local undo
        if (e.ctrlKey && e.altKey && e.key === 'z') {
          e.preventDefault();
          const previousVersion = localVersionControl.undo();
          if (previousVersion !== null) {
            textarea.value = previousVersion;
            // Emit to sync with other clients
            socket.emit("textChange", previousVersion);
            const info = localVersionControl.getVersionInfo();
            showNotification(`âª Restored version ${info.current}/${info.total}`, 'info');
            // Allow saving new changes after navigation
            setTimeout(() => localVersionControl.finishNavigation(), 100);
          } else {
            showNotification('âš ï¸ No more versions to undo', 'warning');
          }
          return;
        }

        // Ctrl+Alt+Y for local redo
        if (e.ctrlKey && e.altKey && e.key === 'y') {
          e.preventDefault();
          const nextVersion = localVersionControl.redo();
          if (nextVersion !== null) {
            textarea.value = nextVersion;
            // Emit to sync with other clients
            socket.emit("textChange", nextVersion);
            const info = localVersionControl.getVersionInfo();
            showNotification(`â© Restored version ${info.current}/${info.total}`, 'info');
            // Allow saving new changes after navigation
            setTimeout(() => localVersionControl.finishNavigation(), 100);
          } else {
            showNotification('âš ï¸ No more versions to redo', 'warning');
          }
          return;
        }

        // Ctrl/Cmd + U for upload
        if ((e.ctrlKey || e.metaKey) && e.key === 'u') {
          e.preventDefault();
          if (!imagePreviewOpen) { // prevent triggering file dialog when preview open
            fileInput.click();
          }
        }
        
        // Ctrl/Cmd + K for clear
        if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
          e.preventDefault();
          clearClipboard();
        }
        
        // Ctrl/Cmd + V for paste (hint for users)
        if ((e.ctrlKey || e.metaKey) && e.key === 'v' && e.target === document.body) {
          showNotification('ðŸ’¡ Tip: You can paste images directly anywhere on this page!', 'info');
        }
        
        // ESC to cancel uploads
        if (e.key === 'Escape' && activeUploads.size > 0) {
          cancelAllUploads();
        }
      });

      // Initialize everything when DOM is loaded
      document.addEventListener('DOMContentLoaded', function() {
        initializeApp();
        attachDeleteEventListeners();
        updateFileCounts();
        updateFileIcons();
        setupImageThumbnails();
        setupTextPreviews();
        setupPDFPreviews();
        
        // Force layout recalculation on mobile to fix flex layout issues
        if (window.innerWidth <= 768) {
          forceLayoutRecalculation();
        }
      });

      // Initialize immediately since we're in the document
      initializeApp();
      attachDeleteEventListeners();
      updateFileCounts();
      updateFileIcons();
      setupImageThumbnails();
      setupTextPreviews();
      setupPDFPreviews();
      
      // Force layout recalculation on mobile after initial render
      if (window.innerWidth <= 768) {
        setTimeout(() => {
          forceLayoutRecalculation();
        }, 100);
      }
      
      // Function to force layout recalculation (fixes mobile flex layout issues)
      function forceLayoutRecalculation() {
        const sidebar = document.querySelector('.sidebar');
        const fileList = document.querySelector('.file-list');
        const sidebarContent = document.querySelector('.sidebar-content');
        
        if (sidebar && fileList && sidebarContent) {
          // Force reflow by reading offsetHeight
          const height = sidebar.offsetHeight;
          
          // Trigger a repaint by temporarily changing a style
          sidebar.style.display = 'none';
          void sidebar.offsetHeight; // Force reflow
          sidebar.style.display = '';
          
          // Also force reflow on file list
          fileList.style.display = 'none';
          void fileList.offsetHeight;
          fileList.style.display = '';
          
          console.log('Mobile layout recalculated');
        }
      }
      
      // Also recalculate on orientation change
      window.addEventListener('orientationchange', function() {
        setTimeout(() => {
          if (window.innerWidth <= 768) {
            forceLayoutRecalculation();
          }
        }, 200);
      });
      
      // Recalculate when window is resized (for when virtual keyboard appears/disappears)
      let resizeTimer;
      window.addEventListener('resize', function() {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          if (window.innerWidth <= 768) {
            forceLayoutRecalculation();
          }
        }, 250);
      });
    </script>
  </body>
</html>
